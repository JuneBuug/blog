---
title   : '로드맵 파헤치기' 
slug  : '/roadmap-digging'
layout  : wiki 
excerpt : 
date    : 2020-12-31 17:12:58 +0900
updated : 2021-07-13 13:46:56
tags    : 
---

## 서론 
roadmap 을 보면서, 내가 아는 것도 어렴풋이 알고 있고 모르는 건 아주 화끈하게 모른다는 점을 알게 되었다. 
머릿속에 정리가 안되는 찜찜한 상태로 있기 보다는, 일단 위키를 만들어서 써내려가기로 했다.
최대한 2-3줄 안에 정리하는게 목적인데 잘 될지는 ! 😮
상세한 설명을 한 나의 블로그 글이 있으면 첨부한다. 



## CS 기본 지식 관련 질문 (네트워크 / 자료구조 / OS / 알고리즘)

  
### OSI 7계층에 대해 아는대로 말해주세요.
 - physical (1) e.g) Fiber / wireless (실제로 회선으로 넘기는 단계)
 - data link (2) e.g) ethernet 
 - network layer (3) e.g) IP , ARP
 - transport layer (4) e.g.) TCP (Transmission Control Protocol), UDP 
 - session layer (5) e.g) socket / APIs 
 - presentation layer (6) e.g.) SSL, SSH 
 - application layer (7) e.g) HTTP, FTP, SSH, DNS

### TCP 와 UDP 의 차이점은 무엇일까요?
OSI 레이어에서 전송 계층 (transport)
데이터의 패킷을 추적 관리
  - TCP (Transmission Control Protocol): 안정성, 순서보장(3-handshake(연결 설정),  4-handshake(연결해제) 많은 어플리케이션이 tcp 기반, 흐름 제어 및 혼잡 제어, 1:1 연결, 응답과 재전송 요청등 때문에 성능이 낮고 스트리밍에 불리, 소켓 기반으로 데이터 전송
    
  - UDP (User Datagram Protocol): 속도가 빠름, 순서보장이 안됨, 주로 VoIP, 하나의 경로가 없이 나눠진 패킷들이 각각 다른 경로로 가게 될 수 있음. (독립적), 정보를 주고 받을 때 신호절차를 거치지않기 때문에 신뢰성은 낮지만 TCP 보다 속도가 빠르다. 서버 - 클라이언트 간 N:M 연결이 가능



### API 에 대해 설명해주세요
> 제품, 서비스가 서로 내부 구현을 알지 못해도 커뮤니케이션을 할 수 있도록 한 명세를 의미.

API를 사용하면 구현 방식을 알지 못해도 제품 또는 서비스가 서로 커뮤니케이션할 수 있으며 애플리케이션 개발을 간소화하여 시간과 비용을 절약할 수 있습니다. 새로운 툴과 제품을 설계하거나 기존 툴과 제품을 관리하는 경우 API는 유연성을 제공하고 설계, 관리, 사용 방법을 간소화하며 혁신의 기회를 제공합니다. 


### 인터넷이 무엇인가요? 
레퍼런스 없이 생각해봤을 때.. internet 이라는 이름부터 파고 들어보자. internet, net 은 여기서 network 이다. 네트워크는 노드와 엣지로 이루어져 정보를 교환하는 '망'을 의미한다.(net) inter-net 은 이 네트워크끼리 소통하는 더 커다란 의미의 네트워크를 의미한다고 볼 수 있다. 

소비자 입장에서 생각해보면 인터넷은 타인의 노드(device)에 브라우저를 통해서 자유롭게 접근하는 망을 의미한다. 이 노드 간 연결은 어떻게 되냐고? 레이어를 쭉 타고 내려가야겠지만 일반적인 인터넷 연결은 TCP-IP를 지나... 노드간에 전송인 transport layer? - data layer - physical layer 까지 거쳐서 정보를 전송한다. 



### 정렬의 종류 및 특징을 설명해 주세요.

- 안정정렬 / 불안정 정렬 
  - 정렬되지 않은 상태에서 중복된 값(같은 키 값)의 정렬 이후에도 입력 순서와 동일하게 정렬 - 안정 
   e.g.) 포커카드를 숫자를 기준으로 정렬했을 때, 5로 겹치는 값은 무늬 순서가 일정하다

- bubble sort
  - 안정 정렬 
  - O(n^2)
  
  
- insertion
  - 안정
  - O(n^2)
  - 기존 자료의 정렬 정도에 따라 최선이 O(n)
  - 앞의 정렬된 배열 부분과 비교하여, 자신의 ㅊ위치를 찾아서 삽입함으로써 정렬을 완성.
    - 두번째부터 시작

- selection sort
  - 최솟값 / 최댓값의 자리는 정해져있고, 전체를 탐색하면서 그 자리에 맞는 걸 찾음
  - 불안정 but 제자리 정렬 (추가메모리 필요없음)
  - O(n^2)

- quick sort 
  - 불안정 
  - pivot을 잘못정하면 최악 O(n^2), 평균적으로 O(nlogn)



- merge sort
 - 안정
 - 파일시스템에서 사용
 - 추가 메모리 공간 필요
  
- heap sort 
 - 불안정
 - O(nlogn)
 - 추가 메모리 필요
 - heap 구조를 만족하도록 하면서, 삽입시 heapify 를 통해 정렬을 맞춰줌 
 - heap 속성을 맞추지않은 상태에서는 루트부터 시작해서 맞춤
 - insert 는 비어있는 가장 아래의 leaf 노드의 가장 왼쪽부터 채워서, 아래부터 맞춰줌

###  WAS의 동작방식에 대해서 설명해주세요.
Web Application server 는 로직을 요구하는 동적인 컨텐츠를 http 통신을 통해 제공하는 기능을 담당. 
servlet 구동환경을 제공하는 서버이기도 함. e.g) tomcat
1.  클라이언트의 요청에 맞는 servlet을 메모리에 올린다.
2. web.xml 을 참조해 해당 서블릿에 대한 쓰레드를 생성한다. 
3. httpservlet request / response 객체를 생성하고, 그에 맞는 doGet / doPOST 메소드를 호출해 생성된 동적 페이지를 response 객체에 담아 was 에 전달한다. 
4. was 는 http response 형태로 바꾸어 웹서버에 전달하고, 생성된 스레드 / servlet request / response를 제거한다. 

+) 스프링과 결합할 때.. 
- spring mvc에서는 dispatcher servlet이라는 모든 요청 담당 서블릿으로 컨트롤러에 위임함.
* servlet : 웹페이지 / 결과값을 동적으로 생성하는 역할을 하는 자바 프로그램

내장 tomcat 내부의 servlet container (~ dispatcher servlet ) 에서 
spring container 로 통신! 
이때 handler mapping / adaptor를 통해서 대상 컨트롤러를 확인하고 요청을 보냄 

=
1. Client -> Web server 으로 request 보냄
2. 동적 Web server -> Servlet container로 전달
3. Servlet container 쓰레드 생성
4. DispatcherServlet init (서블릿 생성 안되어 있을경우)
5. 생성된 쓰레드에서 DispatcherServlet service() 메서드 호출
6. HandlerMapping을 통해 매핑 컨트롤러 조회
7. HandlerAdapter를 통해 매핑 컨트롤러에 request 전달
8. 개발자가 구현한 Controller -> Service -> Repository … 동작



### 세션과 쿠키를 사용하는 이유는 무엇일까요?
쿠키와 세션 ! 
http 프로토콜 
- connectionless 
   - 클라이언트에게 요청을 반환하면 그 연결을 끊어버리는 특징 
   - keep-alive 로 conneciton을 재활용할 수 있음 (http 1.1 에서는 이것이 기본)
- stateless
  - 통신이 끝나면 상태를 유지하지 않음 

이렇게 안쓰고 싶을 때 쿠키 / 세션 

- 쿠키 : 클라이언트 사이드에서 저장되는 key-value의 데이터 타입. 
  유효시간을 명시할 수 있으며, 그렇게 되면 브라우저 종료해도 인증이 유지됨. 
  클라이언트에 300개 까지 쿠키 저장 가능
  response header에 set-cookie를 사용하면 클라이언트 쪽에 쿠키를 만들어줄 수 있음 
  따로 요청하지않아도 request 시 날아간다. 

- 세션 : 서버 측에서 관리하는 데이터. 
  id를 부여하며, 웹 브라우저가 서버에 접속해서 브라우저를 종료할때까지 인증상태를 유지함.
  접속시간에 제한을 두어서 응답이 없으면 정보가 유지되지않게 설정. 
  쿠키보다 보안은 좋지만, 서버 메모리를 차지하고(동접이 많으면 서버에 과부하)
  

아래는 스토리지 관점에서.. 
[쿠키, 로컬 스토리지, 세션 스토리지 5초만에 알기](https://juneyr.dev/2018-12-26/web-storage)

### 해시테이블에 대해 설명해주세요.

key-value 구조로 데이터를 빠르게 검색이 가능한 자료구조중 하나. 내부적으로 bucket (배열) 을 사용하여 데이터를 저장하고, 각각 키에 해시함수를 적용해서 저장될 버킷을 정하게 된다. 



### 쓰레드와 프로세스의 차이는 무엇일까요?
- 프로세스 
  - 실행되고 있는 컴퓨터 프로그램 자체
  - 운영체제로 부터 시스템 작업을 할당받는 자원의 단위
  - code / data/ stack / heap 의 구조를 가진 메모리를 할당 받음 

  
- 쓰레드 
  - 프로세스에서 실행되고 있는 흐름 단위 
  - 프로세스 내에서 공유 / 비공유 파트가 있고, 병렬 실행 
    - stack만 비공유 
    - code / data / heap 은 공유
  
  - 하드웨어 스레드는 os가 스케쥴 해줄 수 있는 최소 단위의 일 


[하드웨어 스레드와 소프트웨어 스레드](https://juneyr.dev/thread)
> 여기서의 스레드는 소프트웨어 스레드를 의미한다. 이 스레드는 소프트웨어 상에서 병렬적으로 task 를 나누고, 일을 할당할 때 쓰인다. 이 스레드가 고대로 하드웨어 스레드에 올라가서 사용된다. 즉, 소프트웨어 스레드가 100개가 있다고 하더라도 동시에 실행될 수 있는 스레드는 하드웨어 스레드 갯수와 같다.

### MVC 패턴에 대해서 설명해주세요.
Model - View - Controller
DB에 저장되며 - 도메인을 코드화한 Model, 사용자에게 보이는 부분인 View, 이 두개의 매개가 되어주는 Controller 




## Spring / Java / OOP

### Spring이 무엇인가요? 
스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이다. 

### JavaBean 
아래 두가지 관례에 따라 만들어진 오브젝트
- 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티: 자바빈이 노출하는 이름을 가진 속성. getter, setter

### Spring의 Bean, BeanFactory
- 빈 :  스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
- 빈팩토리:  빈 생성, 관계설정 같이 제어를 담당하는 IoC 오브젝트
- application context : 빈 팩토리를 확장한 IoC 컨테이너, 빈 팩토리의 기능 + 스프링이 제공하는 각종 부가 서비스를 추가로 제공
빈 팩토리라고 부를 때는 주로 빈 생성과 제어의 관점, 애플리케이션 컨텍스트라고 할 떄는 스프링이 제공하는 애플리케이션 지원 기능을 포함하는 것
ApplicationContext는 BeanFactory를 상속


### 상속이 반드시 좋은 방법이 아닌 이유 
상속을 통한 상하위 클래스의 관계는 생각보다 밀접해있어 다른 관심사 간 긴밀한 결합을 허용한다.
상속을 통해 만들어진 구현체가 중복을 발생시킬 수 있다.

### IoC (Inversion of Control) 
제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 즉 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다! 당연히 생성하지도 않는다. 모든 제어 권한을 다른 대상에게 위임하기 때문이다. 예를 들어, 서블릿을 개발해서 서버에 배포할 수 있지만 서블릿의 실행을 직접 제어할 수 있는 방법은 없다.
프레임워크도 제어의 역전 기술이 적용된 대표적인 기술이다. 흔히 라이브러리와 혼동하고는 하는데, 큰 잘못이다. 우리는 라이브러리를 능동적으로 사용한다. 반면 프레임 워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
즉 우리는 스프링 없이도 작은 IoC 프레임워크를 사용한 셈이다. 제어의 역전에는 프레임워크 혹은 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관게설정, 생명주기 관리 등을 관장하는 존재가 필요하다. 단순한 적용이면 우리의 예제로 충분하지만, 애플리케이션 전반에 IoC를 사용하고 싶다면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 유리하다. 🦦



### JVM, JRE, JDK 를 설명해주세요.
java virtual machine (환경)
- 자바 가상 머신. 소스코드로 만들어지는 자바 바이너리 파일 (.class) 를 실행할 수 있음. 

- 자체적으로는.. 환경(플랫폼) 의존적이지만, JVM 이 있어 컴파일된 파일은 어떤 JVM 에서도 동작시킬 수 있다. 

java run env
- JVM 이 자바프로그램을 동작시킬때 필요한 라이브러리와 기타 파일을 가지고 있음.
- JVM 의 실행환경. 

java development kit 
- 자바 클래스 라이브러리(Java class libraries)와 자바 클래스 로더(Java class loader), 자바 가상 머신(Java Virtual Machine)이 포함된다.

- JDK 안에 JRE. JRE + 개발을 위해 필요한 도구 (javac, java )

### final 키워드에 대해 설명해주세요.
변수의 상수화 (modification 불가능)
- get 만 가능
- 메소드에 사용된 경우, 오버라이딩 불가능 🤨
- 클래스에 사용된 경우, 상속이 불가능 

### Checked Exception / Unchecked exception 

> 우리가 예외적인 조건 이라고 말할 때는 이 세가지 경우 중 하나를 의미합니다.

- Checked Exceptions
- 개발자도 예상하고 대처할 수 있는 exception 
- 컴파일러가 명시적으로 고쳐달라고 함
- 트랜잭션을 롤백하지 않음 

- Unchecked Exceptions / Runtime Exceptions (같다고 생각하시면 됩니다.)
- runtime exception의 상속체
- 트랜잭션을 롤백함

- Errors

[[번역] 자바에서의 예외처리](https://juneyr.dev/2019-10-04/exception-handling-translation)


**대처법** 
- throws / throw
- try - catch 
- try - catch - finally 
- try with resources


### 영속성 컨텍스트 - JPA (/hibernate) 
엔티티를 저장하는 환경. 하나하나를 식별자로 구별한다. 
entitymanager 하나 당 하나의 context가 만들어짐! 

JPA는 트랜잭션을 커밋하는 순간, 영속성 컨텍스트에서 새롭게 저장된 엔티티를 데이터베이스 반영함. 
커밋 전에는, 영속성 컨텍스트에 있고. (1차 캐시, map 형태로 엔티티를 저장)
- 1차 캐시에서 인스턴스를 반환하기 때문에 같은 객체임을 보장한다. 
- 쓰기 지연 지원 (커밋 전까지는 DB에 저장하지 않고, 내부에 쿼리를 생성해둠)
- flush 시점에 스냅샷과 엔티티를 비교해서 변경된 entity를 찾는다. 
- 지연로딩(프록시 객체를 로딩해두고, 실제 사용할때만 영속성 컨텍스트를 통해 데이터를 불러오는 방법)


[JPA 영속성 컨텍스트 정리](https://juneyr.dev/2019-02-28/jpa-persistence)

####  n+1 문제 

1: N 상황에서, 하위 엔티티들을 첫 쿼리 실행시에 한번에 가져오지 않고, lazy loading으로 가져올 때 쿼리가 실행될 때 쿼리가 과도하게 늘어나는 현상

예를 들어, 게시글 1: 리뷰 N 개로 엔티티 관계가 맺어져있다 (ManyToOne(FetchType Lazy))고 하면 
게시글 목록 A개를 가져오는 로직 실행시 
게시글 가져오는 쿼리 (1) + 각 게시글마다 리뷰를 가져오는 쿼리 (A개) 
식으로 쿼리가 늘어나게됨

해결 방법)
- FetchType을 eager로 (가져올 때 가져오도록) 
- fetch join 를 사용



####  open session in view
true일 경우, 영속성 컨텍스트가 트랜잭션 범위를 넘어선 레이어까지 살아있다. 
- api 라면 클라이언트에게 응답될 때까지
- view 반환이면 view 렌더링까지 영속성 컨텍스트가 살아있음

- 영속성 컨텍스트가 살아있으면 수정이 가능, 기본값은 true
- db connection을 계속 갖고 있음. 성능이 중요하다면 false로 .. 

[출처](https://gracelove91.tistory.com/100)

####  @Transactional 동작과정 

Spring에서, 바이트 코드 위빙 같은 고급기술을 활용할 수는 없고  + 그렇다고 내가 작성한 자바코드에 재작성할수도 없음. 대신 IoC Container를 사용해서 트랜잭션 프록시를 인스턴스화해서, 마치 코드를 넣는 것처럼 동작하게 함. 
트랜잭션 처리를 트랜잭션 매니저에게 위임해서 처리하게 함. 

`@Transactional` 을 찾으면, 빈의 다이나믹 프록시를 만들어서! 해당 빈이 트랜잭션 매니저에 접근하고, JDBC 방식으로 트랜잭션 매니저가 코드를 실행해줌.

propagation level
- required : 트랜잭션을 필요로 하긴 함 (재사용이나 새로 만드는 방식은 일단 상관하지않겠음)
- supports : JDBC 가 아무것도 하지않음. 트랜잭션이 있어도 상관없음 1
- mandatory: 트랜잭션이 꼭 필요해 but 내가 안만듬
- required_new: 새로 트랜잭션 만들어서 함

아ㅠㅠ 토비에 있었는데! 추가로 이해 필요


hibernate와 결합하면.. 

hibernate는 sessionFactory 로 트랜잭션을 관리함. 
스프링의 `@Transcational` 은 모름

DataSourcePlatformTransactionManager -> Hibernate/JPA Transaction Manager로 이미 통합해둠!

[출처](https://jeong-pro.tistory.com/228)

  


### 자바 컬렉션 종류와 특징에 대해 설명해주세요.
- ArrayList
  - 순서가 있고, 중복 허용, 인덱스를 통한 랜덤 액세스
- Set
  - 순서가 없고, 중복을 허용하지않음. 랜덤 액세스 불가능

- Map (HashMap) 
  - key-value 구조의 저장방식, key를 통한 액세스 가능 
  - Hashmap은 hashtable을 통한 저장방식을 지원 


###  자바의 메모리 영역에 대해 설명해주세요.
 
 - JVM 메모리 - heap, java stack, class, native method
 - 여기에서 gc를 하고 인식하는 메모리 영역은 힙 
  
 - heap 에서 young / old / perm (permanent 로 나뉘게됨) 
   

###  객체지향 프로그래밍에 대해 설명해주세요.
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법


### spring interceptor / filter 


### 스트링과 스트링버퍼의 차이에 대해 설명해주세요.

### 자바의 데이터 타입인 Primitive Type(기본형) 에 대해 말해보세요.
  int / float / double / long /short ? 
  
  object를 상속한 객체타입이 아니기때문에 null을 받을 수 없지만, wrapper class를 unbox 하는 과정이 없기때문에 
  연산속도가 빠르다! 
  
### 접근제어자의 종류와 특성에 대해 설명해보세요.
  - public / protected / private 
  - 모든 class / 같은 패키지 / 같은 클래스 
  


  
### Interface와 Abstract에 대해 말해주세요.
  - abstract 부터 설명 
    - 구체적인 구현이 없는 명세에 해당하는 메소드 (혹은 클래스) 에 부여하는 
      accessor..? 
  - abstract class는 abstract method가 하나라도 있는 클래스를 말하고, 구체적인 메소드가 있어도됨 
  
  - interface는 모든 메소드가 추상메소드의 형태를 띄는 클래스를 의미. 
 


### 쓰레드를 구현하기 위한 인터페이스, 클래스는 무엇이 있나요?

### static 키워드에 대해 설명해주세요.
- 인스턴스가 공유하는 것이 아닌 class 레벨에서의 값들을 지정할 때 사용하는 키워드? 
  - 필드일수도, 메소드일수도 있음

### 자바 코드의 실행 과정을 설명해주세요.
컴파일 (.class) -> 메모리 로딩 -> jvm 메모리에 올려짐 (heap / stack / native / class) 
함수가 실행될때마다 stack 에 저장되며 할당할 때마다 heap 을 사용하여 실행됨? 

### 오버로딩과 오버라이딩에 대해 설명해주세요.
- 오버로딩 : 같은 함수명, 다른 메소드 시그니처가 가능한 것 
- 오버라이딩 : 상속에서 부모 클래스의 함수를 재정의해서 사용하는 것 


## 디자인 패턴


### Singleton 
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수(1개)만 존재하도록 강제
private 생성자를 갖고 있기 때문에 상속할 수 없다
객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 기술적인 서비스만 제공하는 경우라면 상관없지만 애플리케이션 로직을 담고 있는 일반 오브젝트의 경우 싱글톤이 되면 객체지향의 장점을 적용하기 어렵다.
싱글톤은 테스트하기 힘들다(큰 단점)
싱글톤으로 되어 있어 테스트할때 mock 오브젝트로 대체하기 힘들기 때문에 직접 다 만들어서 사용할 수 밖에 없는데 이런 경우 테스트 오브젝트로 대체하기 어렵다.
서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 생길 수 있음. 여러 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어짐
싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
싱글톤은 사용하는 클라이언트가 정해져있지 않고 스태틱 메서드로 언제든지 접근할 수 있기 때문에 자연스럽게 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 것은 객체지향 프로그래밍에서는 권장되지 않는 모델이다.


## DB / Data Processing 


### 데이터베이스 정규화 과정에 대해 설명해주세요.
- 제 1정규화 
  key 에 다른 모든 column 들이 종속적이지 않도록 하는 것 
  A -> B / A -> C 인 것들을 모두 제거 
  
- 제 2정규화 
  key 에 다른 모든 column 들이 이행-종속적이지 않도록하는것 
  A (key) -> B -> C 인 column 제거 

 

[데이터베이스 기초 - 정규화와 무결성](https://juneyr.dev/2018-11-05/database-normalization)
### Caching - CDN / Redis 

### 데이터베이스 인덱스와 동작 방식 
### NoSQL 
### Data Replication 



### 데이터베이스 트랜잭션이란 무엇인가요?
트랜잭션 (ACID)


## 보안 / 인증 
### OAuth / Basic Auth / Token Auth / JWT
- oauth 흐름
- jwt 개선
- 인증 토큰과 세션을 통한 인증방식
### HTTPS / CORS / SSL /TLS / OWSAP Security RISKS
### MD5 (왜 사용하면 안되는지) SHA family

### ElasticSearch 

### Kafka (메시지 브로커로서) 

## 개발 방법론
### TDD를 해보셨습니까?
### Testing - Integration Test / UnitTest / Functional Test 
### Monolithic / Microservices / SOA / SOA / Serverless

### mitigation strategy ( 경감 전략) 
- Graceful Degradation
- Throttling
- Backpressure
- LoadShifting
- Circuit breaker

## DevOps

### Docker / kubernetes / 가상화 


### Nginx 
- nginx 로드밸런싱? 


### 무중단 배포방식 
- Blue - green 배포 







## 출처 

[자바면접질문: https://mellowp-dev.tistory.com/4](https://mellowp-dev.tistory.com/4)

https://jeong-pro.tistory.com/95 

https://www.itworld.co.kr/news/110768

https://www.redhat.com/ko/topics/api/what-are-application-programming-interfaces

https://smjeon.dev/etc/interview-question/


https://ratsgo.github.io/data%20structure&algorithm/2017/09/27/heapsort/

https://new-be.tistory.com/3

https://taes-k.github.io/2020/02/16/servlet-container-spring-container/

https://gracelove91.tistory.com/100