---
title   : '로드맵 파헤치기' 
slug  : '/roadmap-digging'
layout  : wiki 
excerpt : 
date    : 2020-12-31 17:12:58 +0900
updated : 2021-07-13 13:46:56
tags    : 
---

## 서론 
roadmap 을 보면서, 내가 아는 것도 어렴풋이 알고 있고 모르는 건 아주 화끈하게 모른다는 점을 알게 되었다. 
머릿속에 정리가 안되는 찜찜한 상태로 있기 보다는, 일단 위키를 만들어서 써내려가기로 했다.
최대한 2-3줄 안에 정리하는게 목적인데 잘 될지는 ! 😮
상세한 설명을 한 나의 블로그 글이 있으면 첨부한다. 



## CS 기본 지식 관련 질문 (네트워크 / 자료구조 / OS / 알고리즘)

  
### OSI 7계층에 대해 아는대로 말해주세요.
 - physical (1) e.g) Fiber / wireless (실제로 회선으로 넘기는 단계)
 - data link (2) e.g) ethernet 
 - network layer (3) e.g) IP , ARP
 - transport layer (4) e.g.) TCP (Transmission Control Protocol), UDP 
 - session layer (5) e.g) socket / APIs 
 - presentation layer (6) e.g.) SSL, SSH 
 - application layer (7) e.g) HTTP, FTP, SSH, DNS

### TCP 와 UDP 의 차이점은 무엇일까요?
OSI 레이어에서 전송 계층 (transport)
데이터의 패킷을 추적 관리
  - TCP (Transmission Control Protocol): 안정성, 순서보장(3-handshake(연결 설정),  4-handshake(연결해제) 많은 어플리케이션이 tcp 기반, 흐름 제어 및 혼잡 제어, 1:1 연결, 응답과 재전송 요청등 때문에 성능이 낮고 스트리밍에 불리, 소켓 기반으로 데이터 전송
    
  - UDP (User Datagram Protocol): 속도가 빠름, 순서보장이 안됨, 주로 VoIP, 하나의 경로가 없이 나눠진 패킷들이 각각 다른 경로로 가게 될 수 있음. (독립적), 정보를 주고 받을 때 신호절차를 거치지않기 때문에 신뢰성은 낮지만 TCP 보다 속도가 빠르다. 서버 - 클라이언트 간 N:M 연결이 가능



### API 에 대해 설명해주세요
> 제품, 서비스가 서로 내부 구현을 알지 못해도 커뮤니케이션을 할 수 있도록 한 명세를 의미.

API를 사용하면 구현 방식을 알지 못해도 제품 또는 서비스가 서로 커뮤니케이션할 수 있으며 애플리케이션 개발을 간소화하여 시간과 비용을 절약할 수 있습니다. 새로운 툴과 제품을 설계하거나 기존 툴과 제품을 관리하는 경우 API는 유연성을 제공하고 설계, 관리, 사용 방법을 간소화하며 혁신의 기회를 제공합니다. 


### 인터넷이 무엇인가요? 
레퍼런스 없이 생각해봤을 때.. internet 이라는 이름부터 파고 들어보자. internet, net 은 여기서 network 이다. 네트워크는 노드와 엣지로 이루어져 정보를 교환하는 '망'을 의미한다.(net) inter-net 은 이 네트워크끼리 소통하는 더 커다란 의미의 네트워크를 의미한다고 볼 수 있다. 

소비자 입장에서 생각해보면 인터넷은 타인의 노드(device)에 브라우저를 통해서 자유롭게 접근하는 망을 의미한다. 이 노드 간 연결은 어떻게 되냐고? 레이어를 쭉 타고 내려가야겠지만 일반적인 인터넷 연결은 TCP-IP를 지나... 노드간에 전송인 transport layer? - data layer - physical layer 까지 거쳐서 정보를 전송한다. 



### 정렬의 종류 및 특징을 설명해 주세요.

- 안정정렬 / 불안정 정렬 
  - 정렬되지 않은 상태에서 중복된 값(같은 키 값)의 정렬 이후에도 입력 순서와 동일하게 정렬 - 안정 
   e.g.) 포커카드를 숫자를 기준으로 정렬했을 때, 5로 겹치는 값은 무늬 순서가 일정하다

- bubble sort
  - 안정 정렬 
  - O(n^2)
  
  
- insertion
  - 안정
  - O(n^2)
  - 기존 자료의 정렬 정도에 따라 최선이 O(n)
  - 앞의 정렬된 배열 부분과 비교하여, 자신의 ㅊ위치를 찾아서 삽입함으로써 정렬을 완성.
    - 두번째부터 시작

- selection sort
  - 최솟값 / 최댓값의 자리는 정해져있고, 전체를 탐색하면서 그 자리에 맞는 걸 찾음
  - 불안정 but 제자리 정렬 (추가메모리 필요없음)
  - O(n^2)

- quick sort 
  - 불안정 
  - pivot을 잘못정하면 최악 O(n^2), 평균적으로 O(nlogn)



- merge sort
 - 안정
 - 파일시스템에서 사용
 - 추가 메모리 공간 필요
  
- heap sort 
 - 불안정
 - O(nlogn)
 - 추가 메모리 필요
 - heap 구조를 만족하도록 하면서, 삽입시 heapify 를 통해 정렬을 맞춰줌 
 - heap 속성을 맞추지않은 상태에서는 루트부터 시작해서 맞춤
 - insert 는 비어있는 가장 아래의 leaf 노드의 가장 왼쪽부터 채워서, 아래부터 맞춰줌

###  WAS의 동작방식에 대해서 설명해주세요.
Web Application server 는 로직을 요구하는 동적인 컨텐츠를 http 통신을 통해 제공하는 기능을 담당. 
servlet 구동환경을 제공하는 서버이기도 함. e.g) tomcat
1.  클라이언트의 요청에 맞는 servlet을 메모리에 올린다.
2. web.xml 을 참조해 해당 서블릿에 대한 쓰레드를 생성한다. 
3. httpservlet request / response 객체를 생성하고, 그에 맞는 doGet / doPOST 메소드를 호출해 생성된 동적 페이지를 response 객체에 담아 was 에 전달한다. 
4. was 는 http response 형태로 바꾸어 웹서버에 전달하고, 생성된 스레드 / servlet request / response를 제거한다. 

+) 스프링과 결합할 때.. 
- spring mvc에서는 dispatcher servlet이라는 모든 요청 담당 서블릿으로 컨트롤러에 위임함.
* servlet : 웹페이지 / 결과값을 동적으로 생성하는 역할을 하는 자바 프로그램

내장 tomcat 내부의 servlet container (~ dispatcher servlet ) 에서 
spring container 로 통신! 
이때 handler mapping / adaptor를 통해서 대상 컨트롤러를 확인하고 요청을 보냄 

=
1. Client -> Web server 으로 request 보냄
2. 동적 Web server -> Servlet container로 전달
3. Servlet container 쓰레드 생성
4. DispatcherServlet init (서블릿 생성 안되어 있을경우)
5. 생성된 쓰레드에서 DispatcherServlet service() 메서드 호출
6. HandlerMapping을 통해 매핑 컨트롤러 조회
7. HandlerAdapter를 통해 매핑 컨트롤러에 request 전달
8. 개발자가 구현한 Controller -> Service -> Repository … 동작



### 세션과 쿠키를 사용하는 이유는 무엇일까요?
쿠키와 세션 ! 
http 프로토콜 
- connectionless 
   - 클라이언트에게 요청을 반환하면 그 연결을 끊어버리는 특징 
   - keep-alive 로 conneciton을 재활용할 수 있음 (http 1.1 에서는 이것이 기본)
- stateless
  - 통신이 끝나면 상태를 유지하지 않음 

이렇게 안쓰고 싶을 때 쿠키 / 세션 

- 쿠키 : 클라이언트 사이드에서 저장되는 key-value의 데이터 타입. 
  유효시간을 명시할 수 있으며, 그렇게 되면 브라우저 종료해도 인증이 유지됨. 
  클라이언트에 300개 까지 쿠키 저장 가능
  response header에 set-cookie를 사용하면 클라이언트 쪽에 쿠키를 만들어줄 수 있음 
  따로 요청하지않아도 request 시 날아간다. 

- 세션 : 서버 측에서 관리하는 데이터. 
  id를 부여하며, 웹 브라우저가 서버에 접속해서 브라우저를 종료할때까지 인증상태를 유지함.
  접속시간에 제한을 두어서 응답이 없으면 정보가 유지되지않게 설정. 
  쿠키보다 보안은 좋지만, 서버 메모리를 차지하고(동접이 많으면 서버에 과부하)
  

아래는 스토리지 관점에서.. 
[쿠키, 로컬 스토리지, 세션 스토리지 5초만에 알기](https://juneyr.dev/2018-12-26/web-storage)

### 해시테이블에 대해 설명해주세요.

key-value 구조로 데이터를 빠르게 검색이 가능한 자료구조중 하나. 내부적으로 bucket (배열) 을 사용하여 데이터를 저장하고, 각각 키에 해시함수를 적용해서 저장될 버킷을 정하게 된다. 



### 쓰레드와 프로세스의 차이는 무엇일까요?
- 프로세스 
  - 실행되고 있는 컴퓨터 프로그램 자체
  - 운영체제로 부터 시스템 작업을 할당받는 자원의 단위
  - code / data/ stack / heap 의 구조를 가진 메모리를 할당 받음 

  
- 쓰레드 
  - 프로세스에서 실행되고 있는 흐름 단위 
  - 프로세스 내에서 공유 / 비공유 파트가 있고, 병렬 실행 
    - stack만 비공유 
    - code / data / heap 은 공유
  
  - 하드웨어 스레드는 os가 스케쥴 해줄 수 있는 최소 단위의 일 


[하드웨어 스레드와 소프트웨어 스레드](https://juneyr.dev/thread)
> 여기서의 스레드는 소프트웨어 스레드를 의미한다. 이 스레드는 소프트웨어 상에서 병렬적으로 task 를 나누고, 일을 할당할 때 쓰인다. 이 스레드가 고대로 하드웨어 스레드에 올라가서 사용된다. 즉, 소프트웨어 스레드가 100개가 있다고 하더라도 동시에 실행될 수 있는 스레드는 하드웨어 스레드 갯수와 같다.

### MVC 패턴에 대해서 설명해주세요.
Model - View - Controller
DB에 저장되며 - 도메인을 코드화한 Model, 사용자에게 보이는 부분인 View, 이 두개의 매개가 되어주는 Controller 




## Spring / Java / OOP

### Spring이 무엇인가요? 
스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이다. 

### JavaBean 
아래 두가지 관례에 따라 만들어진 오브젝트
- 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티: 자바빈이 노출하는 이름을 가진 속성. getter, setter

### Spring의 Bean, BeanFactory
- 빈 :  스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
- 빈팩토리:  빈 생성, 관계설정 같이 제어를 담당하는 IoC 오브젝트
- application context : 빈 팩토리를 확장한 IoC 컨테이너, 빈 팩토리의 기능 + 스프링이 제공하는 각종 부가 서비스를 추가로 제공
빈 팩토리라고 부를 때는 주로 빈 생성과 제어의 관점, 애플리케이션 컨텍스트라고 할 떄는 스프링이 제공하는 애플리케이션 지원 기능을 포함하는 것
ApplicationContext는 BeanFactory를 상속


### 상속이 반드시 좋은 방법이 아닌 이유 
상속을 통한 상하위 클래스의 관계는 생각보다 밀접해있어 다른 관심사 간 긴밀한 결합을 허용한다.
상속을 통해 만들어진 구현체가 중복을 발생시킬 수 있다.

### IoC (Inversion of Control) 
제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 즉 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다! 당연히 생성하지도 않는다. 모든 제어 권한을 다른 대상에게 위임하기 때문이다. 예를 들어, 서블릿을 개발해서 서버에 배포할 수 있지만 서블릿의 실행을 직접 제어할 수 있는 방법은 없다.
프레임워크도 제어의 역전 기술이 적용된 대표적인 기술이다. 흔히 라이브러리와 혼동하고는 하는데, 큰 잘못이다. 우리는 라이브러리를 능동적으로 사용한다. 반면 프레임 워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
즉 우리는 스프링 없이도 작은 IoC 프레임워크를 사용한 셈이다. 제어의 역전에는 프레임워크 혹은 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관게설정, 생명주기 관리 등을 관장하는 존재가 필요하다. 단순한 적용이면 우리의 예제로 충분하지만, 애플리케이션 전반에 IoC를 사용하고 싶다면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 유리하다. 🦦



### JVM, JRE, JDK 를 설명해주세요.
java virtual machine (환경)
- 자바 가상 머신. 소스코드로 만들어지는 자바 바이너리 파일 (.class) 를 실행할 수 있음. 

- 자체적으로는.. 환경(플랫폼) 의존적이지만, JVM 이 있어 컴파일된 파일은 어떤 JVM 에서도 동작시킬 수 있다. 

java run env
- JVM 이 자바프로그램을 동작시킬때 필요한 라이브러리와 기타 파일을 가지고 있음.
- JVM 의 실행환경. 

java development kit 
- 자바 클래스 라이브러리(Java class libraries)와 자바 클래스 로더(Java class loader), 자바 가상 머신(Java Virtual Machine)이 포함된다.

- JDK 안에 JRE. JRE + 개발을 위해 필요한 도구 (javac, java )

### final 키워드에 대해 설명해주세요.
변수의 상수화 (modification 불가능)
- get 만 가능
- 메소드에 사용된 경우, 오버라이딩 불가능 🤨
- 클래스에 사용된 경우, 상속이 불가능 

### Checked Exception / Unchecked exception 

> 우리가 예외적인 조건 이라고 말할 때는 이 세가지 경우 중 하나를 의미합니다.

- Checked Exceptions
- 개발자도 예상하고 대처할 수 있는 exception 
- 컴파일러가 명시적으로 고쳐달라고 함
- 트랜잭션을 롤백하지 않음 

- Unchecked Exceptions / Runtime Exceptions (같다고 생각하시면 됩니다.)
- runtime exception의 상속체
- 트랜잭션을 롤백함

- Errors

[[번역] 자바에서의 예외처리](https://juneyr.dev/2019-10-04/exception-handling-translation)


**대처법** 
- throws / throw
- try - catch 
- try - catch - finally 
- try with resources


### 영속성 컨텍스트 - JPA (/hibernate) 
엔티티를 저장하는 환경. 하나하나를 식별자로 구별한다. 
entitymanager 하나 당 하나의 context가 만들어짐! 

JPA는 트랜잭션을 커밋하는 순간, 영속성 컨텍스트에서 새롭게 저장된 엔티티를 데이터베이스 반영함. 
커밋 전에는, 영속성 컨텍스트에 있고. (1차 캐시, map 형태로 엔티티를 저장)
- 1차 캐시에서 인스턴스를 반환하기 때문에 같은 객체임을 보장한다. 
- 쓰기 지연 지원 (커밋 전까지는 DB에 저장하지 않고, 내부에 쿼리를 생성해둠)
- flush 시점에 스냅샷과 엔티티를 비교해서 변경된 entity를 찾는다. 
- 지연로딩(프록시 객체를 로딩해두고, 실제 사용할때만 영속성 컨텍스트를 통해 데이터를 불러오는 방법)


[JPA 영속성 컨텍스트 정리](https://juneyr.dev/2019-02-28/jpa-persistence)

####  n+1 문제 

1: N 상황에서, 하위 엔티티들을 첫 쿼리 실행시에 한번에 가져오지 않고, lazy loading으로 가져올 때 쿼리가 실행될 때 쿼리가 과도하게 늘어나는 현상

예를 들어, 게시글 1: 리뷰 N 개로 엔티티 관계가 맺어져있다 (ManyToOne(FetchType Lazy))고 하면 
게시글 목록 A개를 가져오는 로직 실행시 
게시글 가져오는 쿼리 (1) + 각 게시글마다 리뷰를 가져오는 쿼리 (A개) 
식으로 쿼리가 늘어나게됨

해결 방법)
- FetchType을 eager로 (가져올 때 가져오도록) 
- fetch join 를 사용



####  open session in view
true일 경우, 영속성 컨텍스트가 트랜잭션 범위를 넘어선 레이어까지 살아있다. 
- api 라면 클라이언트에게 응답될 때까지
- view 반환이면 view 렌더링까지 영속성 컨텍스트가 살아있음

- 영속성 컨텍스트가 살아있으면 수정이 가능, 기본값은 true
- db connection을 계속 갖고 있음. 성능이 중요하다면 false로 .. 

[출처](https://gracelove91.tistory.com/100)

####  @Transactional 동작과정 

Spring에서, 바이트 코드 위빙 같은 고급기술을 활용할 수는 없고  + 그렇다고 내가 작성한 자바코드에 재작성할수도 없음. 대신 IoC Container를 사용해서 트랜잭션 프록시를 인스턴스화해서, 마치 코드를 넣는 것처럼 동작하게 함. 
트랜잭션 처리를 트랜잭션 매니저에게 위임해서 처리하게 함. 

`@Transactional` 을 찾으면, 빈의 다이나믹 프록시를 만들어서! 해당 빈이 트랜잭션 매니저에 접근하고, JDBC 방식으로 트랜잭션 매니저가 코드를 실행해줌.

propagation level
- required : 트랜잭션을 필요로 하긴 함 (재사용이나 새로 만드는 방식은 일단 상관하지않겠음)
- supports : JDBC 가 아무것도 하지않음. 트랜잭션이 있어도 상관없음 1
- mandatory: 트랜잭션이 꼭 필요해 but 내가 안만듬
- required_new: 새로 트랜잭션 만들어서 함

아ㅠㅠ 토비에 있었는데! 추가로 이해 필요


hibernate와 결합하면.. 

hibernate는 sessionFactory 로 트랜잭션을 관리함. 
스프링의 `@Transcational` 은 모름

DataSourcePlatformTransactionManager -> Hibernate/JPA Transaction Manager로 이미 통합해둠!

[출처](https://jeong-pro.tistory.com/228)

  


### 자바 컬렉션 종류와 특징에 대해 설명해주세요.
- ArrayList
  - 순서가 있고, 중복 허용, 인덱스를 통한 랜덤 액세스
- Set
  - 순서가 없고, 중복을 허용하지않음. 랜덤 액세스 불가능

- Map (HashMap) 
  - key-value 구조의 저장방식, key를 통한 액세스 가능 
  - Hashmap은 hashtable을 통한 저장방식을 지원 


### 자바 코드의 실행 과정을 설명해주세요.
컴파일 (.class) -> 메모리 로딩 -> jvm 메모리에 올려짐 (heap / stack / native / class) 
함수가 실행될때마다 stack 에 저장되며 할당할 때마다 heap 을 사용하여 실행됨.

###  자바의 메모리 영역에 대해 설명해주세요.
 
- JVM 메모리 - heap, java stack, class, native method

- method (static)
  - jvm 이 읽어들인 클래스, 인터페이스의 런타임 상수 풀, 필드, 클래스 변수 

- stack 
  - 스레드마다 하나씩. 
  - 메소드 호출할때마다. 
  - 원시타입 변수는 여기에 값을 가짐

- native method 
  - JNI 등을 통해 호출되는 자바외 언어 네이티브 코드를 위한 스택

- 여기에서 gc를 하고 인식하는 메모리 영역은 힙 
- 모든 자바 클래스의 인스턴스와 배열이 할당되기도 함.
  
 - heap 에서 young / old / perm (permanent 로 나뉘게됨) 
   - young (young space)
   - old와 permanent가 있는 old space 

young space가 가득차면 young collection을 실행하여 gc를 한다. 어느정도 오래 머문 객체는 old space로 이동한다. 





###  객체지향 프로그래밍에 대해 설명해주세요.
- 프로그래밍에서 필요한 데이터를 추상화시켜 상태와 행위를 가진 객체를 만들고 그 객체들 간의 유기적인 상호작용을 통해 로직을 구성하는 프로그래밍 방법


### spring interceptor / filter 

servlet request -> filter -> dispatcher servlet -> interceptor -> aop -> controller 순 

- filter 
  - 응답 자체를 거르고 정제함. dispatcher servlet 전에 실행
  - 자원 처리 끝나고 정제처리 가능 
  - 인코딩, 체크

- interceptor 
   - 스프링 내부에 있음
   - 스프링의 모든 빈 객체에 접근가능
   - 여러 개 사용 가능
   - preHandler 
   - postHandler 

### 스트링과 스트링버퍼의 차이에 대해 설명해주세요.
- new 로 생성하는 방법
  - heap 영역에 저장 
- 리터럴 생성 
  - string constatnt pool 에 저장, 동일 문자열은 동일 주소값 반환
  - 자바 7까지 perm -> heap 으로 바뀌었다구함(perm은 고정이라 OOM 될까봐)


- String: 불변성 
  - 수정하는 시점에 새로운 인스턴스, but 변하지않는 문자열은 괜찮은 성능

- String buffer / builder : 가변성 
  - 동일 객체내에서 문자열 변경 가능 
  - `new StringBuffer("hello");` `sb.append("Hello")`
  - buffer : 동기화 키워드를 지원해서 멀티쓰레드에 안전
  - builder: 동기화 지원하지않음, but 단일쓰레드성능이 뛰어남


### 자바의 데이터 타입인 Primitive Type(기본형) 에 대해 말해보세요.
  int / float / double / long /short ? 
  
  object를 상속한 객체타입이 아니기때문에 null을 받을 수 없지만, wrapper class를 unbox 하는 과정이 없기때문에 
  연산속도가 빠르다! 
  
### 접근제어자의 종류와 특성에 대해 설명해보세요.
  - public / protected / private 
  - 모든 class / 같은 패키지 / 같은 클래스 
  

  
### Interface와 Abstract에 대해 말해주세요.
  - abstract 부터 설명 
    - 구체적인 구현이 없는 명세에 해당하는 메소드 (혹은 클래스) 에 부여하는 
      accessor..? 
  - abstract class는 abstract method가 하나라도 있는 클래스를 말하고, 구체적인 메소드가 있어도됨 
  
  - interface는 모든 메소드가 추상메소드의 형태를 띄는 클래스를 의미. 
 


### 쓰레드를 구현하기 위한 인터페이스, 클래스는 무엇이 있나요?
- Thread 클래스
  - run 메소드만 오버라이딩
- Runnable 인터페이스 
  - 인터페이스니까 다중 상속 구현 가능 

### static 키워드에 대해 설명해주세요.
- 인스턴스가 공유하는 것이 아닌 class 레벨에서의 값들을 지정할 때 사용하는 키워드
  - 필드일수도, 메소드일수도 있음




### 오버로딩과 오버라이딩에 대해 설명해주세요.
- 오버로딩 : 같은 함수명, 다른 메소드 시그니처가 가능한 것 
- 오버라이딩 : 상속에서 부모 클래스의 함수를 재정의해서 사용하는 것 


## 디자인 패턴


### Singleton 
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수(1개)만 존재하도록 강제
private 생성자를 갖고 있기 때문에 상속할 수 없다
객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 기술적인 서비스만 제공하는 경우라면 상관없지만 애플리케이션 로직을 담고 있는 일반 오브젝트의 경우 싱글톤이 되면 객체지향의 장점을 적용하기 어렵다.
싱글톤은 테스트하기 힘들다(큰 단점)
싱글톤으로 되어 있어 테스트할때 mock 오브젝트로 대체하기 힘들기 때문에 직접 다 만들어서 사용할 수 밖에 없는데 이런 경우 테스트 오브젝트로 대체하기 어렵다.
서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 생길 수 있음. 여러 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어짐
싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
싱글톤은 사용하는 클라이언트가 정해져있지 않고 스태틱 메서드로 언제든지 접근할 수 있기 때문에 자연스럽게 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 것은 객체지향 프로그래밍에서는 권장되지 않는 모델이다.


## DB / Data Processing 


### 데이터베이스 정규화 과정에 대해 설명해주세요.

정규화는 하나의 릴레이션에 하나의 의미만 존재하도록 릴레이션을 분해하는 과정이다.

- 제 1정규화 
  중복되는 항목이 없어야한다 (도메인이 원자값으로 되어있어야한다.)
  
- 제 2정규화 
  부분 함수적 종속 관계를 제거해야 함
  위 테이블에서 candidate key는 종업원 + 기술이다. 그런데 근무지는 종업원이 근무하는 곳이므로 항상 종업원에 종속적인 관계를 갖는다. 키의 일부에만 종속적인 관계를 가지는 것을 부분 함수적 종속 관계라고 하며,
 
- 제3정규형(3NF)
  이행 함수적 종속 제거 ( x→ y→ z), transitive하지 않게 하기!
   대회 + 연도를 키로 우승자가 결정된다. 또 우승자에 따라서 우승자 생년월일이 결정된다. 즉 x → y , y → z 인 관계를 이행 함수적 종속 이라고 한다. 

- BC(Boyce-codd) 정규형 (BCNF)
  결정자이면서 후보키가 아닌 것을 제거하는 정규형

[데이터베이스 기초 - 정규화와 무결성](https://juneyr.dev/2018-11-05/database-normalization)

### Caching - CDN / Redis 


Redis: 메모리 기반의 key-value 스토리지. 
빠르고, 다양한 데이터 구조체를 지원함 
- 큐, Cache, dictionary, 세션 용도로 다양하게 사용함 
- 데이터 유실을 그래도 막기 위해서 두가지 방식 사용 
  - 스냅샷
  - AOF (Append on File): 명령어 로깅
- 싱글 스레드

CDN: 서버와 사용자 사이의 물리적 거리를 줄여서 웹 페이지 로드 지연을 최소화하는 네트워크 (Contents Delivery Network)


[Redis 뭔지나 알고가자](https://juneyr.dev/2019-03-29/redis-basics)
### 데이터베이스 인덱스와 동작 방식 

추가적인 쓰기와 저장공간을 활용하여 데이터베이스 테이블의 검색속도를 향상시키기 위한 자료구조. 

- 약 10%에 해당하는 저장공간
- 인덱스 관리 작업이 필요함 

대표적인 자료구조는 hashtable / b+tree

해시는 등호 연산만 특화되어있어서 부등호 연산이 자주 사용되는 db 검색의 경우 해시테이블이 적합하지않음. 

b+tree는 자식 노드가 2개 이상인 b-tree를 개선시킨 자료구조 
- 리프노드만 인덱스 + 데이터이고, 나머지는 모두 인덱스만 갖는다.
- 리프 노드들이 linked list로 연결되어있다. 

[참고](https://mangkyu.tistory.com/96)

### NoSQL 
RDBMS에서의 문제 (대용량 서비스, 비용적 문제, 데이터 분산)...을 해결하기 위해 등장한 schema-free 한 구조의 데이터베이스. 

e.g.) MongoDB 
- document based 
- 자체적으로 분산처리, 샤딩, 데이터 리밸런싱, 복제, 복구등을 지원
- 레코드, 칼럼, 인덱스.. 
- 어떤 데이터도 저장할 수 있음, read /write가 뛰어남, scale out 구조 / coversion -mapping 가능
 - join이 없어서, 필요없도록 데이터 구조화 필요 
 - memory mapped file로 파일 엔진 DB. 
 - SQL 을 완전히 이전할 수 없음.

[참고](https://coding-start.tistory.com/273)

### Data Replication 

복제(Replication)은 같은 데이터의 복제본을 네트워크로 연결된 여러 머신에 나눠서 보관하는 일을 말함.

데이터가 계속 변하기때문에 복제가 어려움.

- single leader 
- multi leader 
- leader less 


다뤄야할 문제 : 
- sync / async 할 것인지 
  - 현실적으로 모든 팔로워가 sync한 상황은 어려움 
  - 보통 완전 비동기식으로 구성함. 지속성은 보장하지않지만, 모든 팔로워가 잘못되더라도 리더가 쓰기 가능
- replica가 실패했을때?  
  - 팔로워 실패는 backlog를 보관하기때문에 복구가 비교적 쉬움
  - 리더 실패는 까다로움. 기존 팔로워중 하나를 리더로 변경하고, 클라이언트를 재설정해서 새로운 리더로 쓰기를 전송해야함... 



[[데이터중심어플리케이션설계] 5장. replication](https://juneyr.dev/data-intensive-05)

### 데이터베이스 트랜잭션이란 무엇인가요?
트랜잭션 (ACID)
DBMS에서 처리되는 작업의 논리적 단위 

- Atomicity: all or nothing 실행되거나, 하나라도 오류가 있으면 rollback 된다. 

- Consistency: 트랜잭션이 성공적으로 완료되면, 일관성있는 데이터베이스 시스템이 된다. 

- isolation: 둘 이상의 트랜잭션이 동시에 실행되는 경우, 어느 하나가 다른 것에 영향을 미치거나 연산이 끼어들 수 없다. 

- durability: 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야한다. 


## 보안 / 인증 
### OAuth / Basic Auth / Token Auth / JWT
- oauth 흐름
- jwt 개선
- 인증 토큰과 세션을 통한 인증방식
### HTTPS / CORS / SSL /TLS / OWSAP Security RISKS
### MD5 (왜 사용하면 안되는지) SHA family

### ElasticSearch 

### Kafka (메시지 브로커로서) 

## 개발 방법론
### TDD를 해보셨습니까?
### Testing - Integration Test / UnitTest / Functional Test 
### Monolithic / Microservices / SOA / SOA / Serverless

### mitigation strategy ( 경감 전략) 
- Graceful Degradation
- Throttling
- Backpressure
- LoadShifting
- Circuit breaker

## DevOps

### Docker / kubernetes / 가상화 


### Nginx 
- nginx 로드밸런싱? 


### 무중단 배포방식 
- Blue - green 배포 







## 출처 

[자바면접질문: https://mellowp-dev.tistory.com/4](https://mellowp-dev.tistory.com/4)

https://jeong-pro.tistory.com/95 

https://www.itworld.co.kr/news/110768

https://www.redhat.com/ko/topics/api/what-are-application-programming-interfaces

https://smjeon.dev/etc/interview-question/


https://ratsgo.github.io/data%20structure&algorithm/2017/09/27/heapsort/

https://new-be.tistory.com/3

https://taes-k.github.io/2020/02/16/servlet-container-spring-container/

https://gracelove91.tistory.com/100