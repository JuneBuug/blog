---
title   : '[데이터중심어플리케이션설계] 9장. 일관성과 합의' 
slug    : '/data-intensive-09'
layout  : wiki 
excerpt : 
date    : 2020-11-23 15:12:17 +0900
updated : 2020-11-25 13:09:15
tags    : 
---

# 09. 일관성과 합의 
  8장에서 보았듯이 분산시스템에서는 망할 일 투성이다. 가장 간단한 해결법은 전체 서비스가 실패하도록 두고 에러 메시지를 보여주는 것이다. 그러고 싶지않다면, 결함을 견뎌낼 방법을 찾아야한다. 이 성질을 갖는 애플리케이션을 **내결함성** 이라고한다. 
  
  내결함성을 지닌 시스템을 구축하는 가장 좋은 방법은 유용한 보장을 해주는 범용 추상화를 찾아서 이 보장에 의존하는것이다. 같은 방식으로 분산 시스템에서도 적용될 추상화를 찾아보자. 가장 중요한 추상화 중 하나는 **합의** 이다.이 구현이 있으면 다양한 목적으로 사용할 수 있다. 일단, 분산시스템에서 제공될 수 있는 보장과 추상화의 범위를 알아보고, 그 다음 합의 알고리즘에 대해서 알아보자.


## 일관성 보장 
  복제 데이터베이스는 보통 최소한 **최종적 일관성**을 제공한다. / 수렴이라고 부르는 게 낫다. 
  그러나 이것은 매우 약한 보장이다. **언제** 복제본이 수렴될 지에 대해서는 아무것도 얘기하지 않는다. 
  - 개발자가 구현하기도 어렵다. 단일 스레드 프로그램 변수처럼 동작하지 않으니까. 
  - 약한 보장만 제공하는 DB를 다룰 때는 너무 많은 걸 기대하지 말아야하고, 한계를 알아야한다. 최종적 일관성의 에지케이스는 시스템에 결함이 있거나 동시성이 높을 때만 나타날 수 있어서, 잡기도 어렵다. 
  
  그러니, Data system이 선택적으로 제공할 수 있는 좀더 높은 수준의 **강한 일관성** 모델을 알아보자.
  물론 이건 공짜가 아니다. 강한 보장을 제공하는 시스템은 성능이 나쁘거나, 약한 보장을 제공하는 시스템보다 내결함성이 약할지모른다.
   
## 선형성
  최종적 일관성(약한 보장)을 한 DB의 서로 다른 복제본에 동시에 같은 질문을 하면 두 가지 다른 응답을 받을 가능성이 있다. 만약, DB의 복제본이 **하나만 있다**(는 환상)을 만들어준다면, 훨씬 단순해지지 않을까? 

  이 가정에 입각해서 나온 강한 보장이 바로 **선형성** (원자적 일관성, 강한 일관성, 즉각 일관성, 외부 일관성 이라고도 부른다.) 이다. 위와 같은 보장이 있으면 현실에는 여러 복제본이 있어도 애플리케이션은 거기에 신경 쓸 필요가 없다. 

  선형성 시스템에서는 클라이언트가 쓰기를 완료하자마자, 그 DB를 읽는 모든 클라이언트가 방금 쓰여진 값을 볼 수 있어야한다. 즉, 선형성은 **최신성 보장**(recency gurantee) 이다. 

  ![비선형시스템](./1.png)
  위의 비선형 시스템, 축구 웹사이트 예제를 잠시 보자. 밥은 앨리스가 최종 점수 발표 직후에 홈페이지에 접속했지만, 예전의 값만 보게 된다. 그의 질의가 오래된 결과를 반환했다는 사실은 선형성 위반이다. 

 
### 시스템에 선형성을 부여하는 것은 무엇인가?

기본 아이디어는 역시, 시스템에 데이터 복사본이 하나뿐인 것처럼 만드는 것이다. 예시를 보자.
![읽기요청이 쓰기와 동시에 실행되면](./2.png)
위 그림에서 동시에 같은 키 x를 읽고 쓰는 세 클라이언트를 보여준다. 분산 시스템에서 이 x는 **레지스터**라고 불린다. 현실에서는 key-value의 key, RDB의 로우 하나, 문서DB의 문서 하나가 될 수 있다. 
위 그림처럼 읽기 요청이 쓰기와 동시에 실행되면 과거의 값을 반환할 수도, 새로운 값을 반환할 수도 있다. 
즉 B의 모든 요청, A의 두번째 요청은 쓰기의 영향이 발생했는지 모른다. 이런 경우는 선형적인 시스템이 아니다. 

시스템을 선형적으로 만들려면 위 그림에서 제약 조건을 추가해야한다. 
> 읽기가 새로운 값을 반환한 일이 있었으면, 그 이후의 읽기는 모두 반드시 새로운 값을 반환해야한다. 

![제약조건](./3.png)

선형성 시스템에서 우리는 x가 0 -> 1 인 시점이 있다고 생각한다. 따라서 한 클라이언트의 읽기가 새로운 값 1을 반환하면, 이후의 모든 후속 읽기는 새로운 값이다. **쓰기 연산이 완료되지 않았다고 하더라도 말이다.**

이제 세번째 연산을 추가해보자. compare-and-set이라는 뜻의 cas(x, v1, v2) 는 x==v1 ? v2 : throw 의 뜻이다. 

![새로운연산추가](./4.png)

읽기와 쓰기의 영향이 나타난 것으로 보이는 시점을 시각화 했다. 위 그림에서 몇가지를 알 수 있다. 
- B가 읽기를 시작한 이후, D가 레지스터를 0으로 만들고 이후에 A가 레지스터를 1로 요청한다. 하지만 B가 읽은 값은 1이다. 이 말은 DB가 D->A->B 순으로 요청을 끝냈다는 말이다. **요청을 보낸 순서는 다르지만 세 요청은 동시적이기 때문에 이 순서는 허용된다.** 

- B의 읽기는 A가 성공 응답을 듣기전에 1을 반환했다. 이것도 괜찮다. 
- 이 모델은 어떤 트랜잭션 격리도 가정하지 않는다. 예를 들어 C는 두번의 읽기에서 1, 2를 순서대로 읽었다. 이는 동시점에 B가 값을 변경했기 때문이다. 다만 다른 클라이언트의 값 변경을 확인하기 위해 cas 를 사용한다. 
- B의 마지막 읽기는 선형적이지 않다. A가 이미 4로 읽었기때문이다. 이 연산은 cas 연산과 동시적이기때문에 이런 결과를 받았다. 


여기서 선형성과 직렬성의 차이를 짚고 넘어가자. 

> 직렬성: 모든 트랜잭션들이 여러 객체를 읽고 쓸 수 있는 상황에서의 트랜잭션들의 격리 속성이다. 직렬성은 트랜잭션의 실행 순서와 상관없이 트랜잭션이 어떤 순서에 따라 실행하는 것처럼 동작하게 보장해준다. 

> 선형성: 레지스터 (개별 객체)에 실행되는 읽기와 쓰기에 대한 보장이다. 연산을 트랜잭션으로 묶지 않아서 충돌 구체화 같은 수단을 쓰지 않으면 쓰기 스큐같은 문제를 막지 못한다. (읽은 값 기반으로 쓰지만, 쓰는 시점에는 그 값이 참이 아님)

DB는 이 두가지를 모두 제공할 수도 있고 그 조합은 엄격한 직렬성이나 강한 단일 복사본 직렬성이라고 한다. 2PL 은 선형적이지만, 7장에서 함께 언급한 SSI 은 선형적이지 않다.


### 선형성에 기대기 

어떤 환경에서 선형성이 유용할까? 

- 잠금과 리더 선출 
  - 단일리더 복제를 사용하는 시스템은 리더가 하나만 있도록 보장해야한다. 한 방법은 잠금을 사용하는 것인데, 이 잠금을 구현할 때는 선형적이어야한다. 모든 노드는 어느 노드가 잠금을 소유할지 동의해야한다. 
  - 분산 잠금과 리더 선출에는 아파치 주키퍼나 etcd와 같은 코디네이션 서비스가 종종 사용된다. 이 서비스에서도 선형성 저장소 서비스가 기초가된다. 
- 제약조건과 유일성 보장
  - unique constraint 는 데이터베이스에서 흔하다. 이 상황은 실제로 잠금과 비슷하고, 연산 자체가 compare-and-set과도 비슷하다. 은행 계좌 잔고, 영화좌석과 같은 경우도 제약이 있다. 이 제약들은 **모든 노드가 동의하는 하나의 최신값**을 요구한다. 
  - 이런 경우 선형성이 필요하다. 외래키나 속성 제약같은 건 선형성 없이도 구현할 수 있다. 
- 채널 간 타이밍 의존성 
  - 썸네일 시스템을 생각해보자. 사용자가 이미지를 올리면, 다른 사용자가 쉽게 받을 수 있도록 저해상도로 만드는 시스템이다. 이 썸네일링 명령은 메시지 큐를 통해 웹서버에서 크기 변경 모듈로 보내진다. 
  ![썸네일시스템])(./5.png)
  이 시스템이 선형적이지 않으면, 메시지 큐의 단계가 저장서비스 내부의 복제보다 빠를 수 있다. 그러면 메시지를 받은 모듈이 이미지를 가져오려고할 때 아무것도 못보거나 과거버전만 볼 수 있다. 
  - 이 문제는 웹서버 <->크기 변경 모듈  사이에 두가지 채널, 즉 파일 저장소와 메시지 큐가 있기때문에 발생한다. 선형성의 최신 보장이 없으면 경쟁 조건이 발생할 수 있다. 

### 선형성 시스템 구현하기 
그럼 이제 어떻게 구현할 지 알아봐야한다. 🦦
선형성은 "데이터 복사본이 하나만 있는 것 처럼 동작하는 것" 이므로 정말 데이터 복사본은 하나만 사용하자. 
> 절대 결함을 버텨낼 수 없다. 

결함을 버텨내는 가장 흔한 방법이 복제이므로 .. 복제에서 선형성을 찾아보자. 

- 단일리더복제 (선형적으로 할 수도 있음)
  - 리더나 동기식으로 복제된 팔로워에서 읽으면, 선형적이 **될 수도 있다**.그러나 모든 단일리더 DB가 선형적인 것은 아니다. 동시성 버그나 설계상의 이유가 있다. 
  - 앞선 예시 처럼 split brain이 일어나면 지속성과 선형성을 모두 위반하게 된다.
- 합의 알고리즘(선형적)
  - 이후에 살펴볼 합의 알고리즘은 선형적이다. 합의 프로토콜에는 split brain과 복제본이 뒤처지는 것을 막는 수단이 둘다 있다. e.g.) 주키퍼, etcd 
- 다중 리더 복제(비선형적)
  - 이들은 여러 노드에서 동시에 쓰기를 처리하고, 비동기로 이 내용을 복제하므로 충동 쓰기를 만들어낸다(문제!)
- 리더 없는 복제(아마도 비선형적)
  - 정족수를 통해서 엄격한 일관성을 달성할 수 있다고 주장하는 사람들이 있다. 그러나 정족수 설정과 일관성의 정의에 따르면 이 주장이 완벽한 진실은 아니다. 
  
  #### 선형성과 정족수 
  다이나모 스타일(리더없는 복제) 에서 엄격한 정족수를 사용한 읽기, 쓰기는 선형적인 것처럼 보인다. 그러나 변동이 심하면 경쟁조건이 생길 수 있다. 

  ![정족수를 만족하지만 경쟁 조건인](./6.png)
  정족수가 만족 (w=3, r=2, n=3)되지만 A가 1을 보고, B는 0을 본다. 이런 경우 선형성을 만족하지 않는다. 
  그러나 성능을 비용으로 지불하고 선형적으로 만드는게가능하다.
  - 동기식 읽기 복구
  - 쓰기는 쓰기 전 최신 상태 읽기 
  
  이 방법으로는 선형성 읽기와 쓰기 연산만 구현할 수 있다. 그러므로 다이나모스타일은 선형성을 만족하지 않는다고 보는게 안전하다. 

### 선형성의 비용 
다중 리더 데이터베이스를 생각해보자. 만약 데이터 센터 간 연결이 해제되면, 각 데이터 센터는 따로 따로 정상동작한다. 서로 동기화 안된 부분은 네트워크가 복구되면 따라잡을 수 있다. 
그러나 단일 리더에서 데이터 센터가 분리된 예제에서는, 팔로워 데이터 센터로 접속한 클라이언트가 write할 수 없다. 이 경우 클라이언트는 서비스 중단을 경험한다.

모든 선형성 데이터베이스는 이런 문제가 있다. 이 트레이드 오프를 CAP 정리로 표현한다. 
- 애플리케이션에서 선형성을 요구하고, 네트워크 문제때문에 복제서버가 다른 복제서버와 연결이 끊기면 일부 복제 서버는 연결이 끊긴 동안은 요청을 처리할 수 없다. 
- 애플리케이션에서 선형성을 요구하지 않는다면, 독립적인 방식으로 요청을 처리할 수 있고 따라서 가용한 상태를 유지한다. 

> CAP 은 이 트레이드 오프를 이야기한다. Consistency(일관성), Availablility(가용성), Partition tolerance(분단 내성)이라는 셋 중 둘을 고르라는 식의 해석이 있지만 오해의 소지가 있다. 이는 사실 네트워크 분단이 생겼을 때 일관성과 가용성 중 하나를 고르라는 의미에 가깝다. (네트워크가 정상 작동하면 둘다 챙길 수 있다.)

#### 선형성과 네트워크 지연 
선형성은 유용한 보장이지만 현실에서 실제로 선형적인 시스템은 매우 드물다. e.g.) 최신 다중 코어의 RAM 
만약 하나의 CPU 코어에서 실행 중인 스레드가 메모리 주소(x)에 쓴 후 바로 다른 코어에서 실행되는 스레드가 같은 주소(x)를 읽으면 처음에 읽은 값을 읽으라는 보장이 없다. 

이는 모든 CPU 코어가 저마다의 캐시와 버퍼를 사용하기 때문이다. 캐시가 물론 저장소보다 빠르므로 좋은 성능에 필수적이고, 각자의 저장소를 바라보는 결과를 낳는다. 여기에서 선형성을 제거한 이유는 내결함성이 아니라 성능이다.

선형성은 느리다. 그리고 이는 네트워크 결함이 있을 때뿐만 아니라 항상 참이다. 좀더 효율적인 선형 저장소를 찾으려는 시도가 있었지만, 아직까지는 답이 없다. (p.336) 다만 완화된 일관성 모델은 훨씬 더 빠를 수 있다. 따라서 지연 시간에 민감한 시스템에서는 이 트레이드 오프가 중요하다. 

## 순서화 보장 
선형성 register는 데이터 복사본이 하나만 있는 것 처럼 동작하며, 연산이 순서대로 실행된다는 것을 암시했다. 
**순서** 그리고 **순서화**는 이 책에서 되풀이 된 주제이다 == 즉, 중요하다. 
- 5장 단일 리더 복제에서 복제로그의 쓰기 순서에 대해 배웠다. 순서와 단일 리더가 없으면 충돌이 발생한다. 
- 7장 직렬성에서 트랜잭션이 어떤 일련 순서에 따라 실행되는 보장하는 것을 배웠다.
- 8장에서의 타임스탬프와 시계는 질서를 부여하려는 시도다.

### 순서화와 인과성
순서화는 인과성을 보존하는데 도움을 준다. 
- 일관된 순서로 읽기 : 예지력이 있는 사용자의 예시를 기억하나요? 답변을 먼저보고 질문을 나중에 보게 되는 이 예시는 인과성을 위반했기때문에 혼란스럽다. 
- 네트워크 지연때문에 존재하지 않는 로우를 갱신하는 예제.
- 동시 쓰기 감지에서 happened before 관계를 얘기했다. A < B (시간적으로) 라면, B가 A에 의존하거나 기반으로 한다는 뜻이다. 동시적이면 서로에 대해서 모른다는 뜻이다. 
- 트랜잭션 스냅숏 격리의 맥락에서 일관적 스냅숏을 이야기했다. 일관적은 인과성에 일관적이라는 의미다. 스냅숏에 답변이 포함되면 응답된 질문 또한 포함되어야한다. 
- 쓰기 스큐 예제에서도 인과적 의존성을 보여준다. SSI 는 트랜잭션 사이의 인과적 의존성을 추론해서 쓰기 스큐를 검출한다. (on call 의사 예제)
- 앨리스와 밥의 축구 예제에서 밥이 앨리스가 결과를 외치는 것을 들은 후 서버에서 결과를 확인할 수 없는 것은 인과성 위반이다. (채널 간 타이밍 의존성)

시스템이 인과성에 의해 부과된 순서를 지키면 그 시스템은 인과적으로 일관적이라고 한다. 

#### 인과적 순서가 전체 순서는 아니다
전체 순서는 어떤 두 요소를 비교할 수 있게하므로 두 요소가 있으면 항상 어느 것이 크고 작은지 비교할 수 있다. 이제 집합을 생각해보자. 집합의 크기는 비교가 불가능하다. {a, b} 와 {b,c} 중 어느것이 크고 작은가? 집합은 부분적으로 순서가 정해진다(partially ordered) 이것이 부분 순서이다. 

이 차이는 데이터베이스 일관성 모델에도 반영된다. 

- 선형성
  - 선형성 시스템에서는 연산의 전체 순서를 정할 수 있다. DB 복제본이 하나만 있는 것 처럼 동작하고 연산이 원자적이면 어떤 두 연산에 대해서 항상 둘 중 하나가 먼저 실행되었다고 말할 수 있다. 
- 인과성
  - 두 연산 중 어떤 것도 다른 것보다 먼저 실행되지 않았다면 **동시적**이라고 말한다. 두 연산이 동시에 실행되면 비교할 수 없다. 인과성은 부분 순서를 정의한다. 

이 정의에 따르면 선형성은 동시적 연산이 없다. 하나의 타임라인이 있고, 모든 연산은 해당 타임라인을 따라 순서가 정해져야한다. 

동시성은 타임라인이 갈라졌다 다시 합쳐지는 것을 말한다. 이 경우 다른 branch 에 있는 연산은 비교가 불가능하다. 

#### 선형성은 인과적 일관성보다 강하다

그러면 이런 결론에 다다른다. `선형성은 인과성을 포함한다.` 어떤 시스템이든지 선형적이라면 일관성도 올바르게 유지한다. 좋은 소식처럼 보이지만, 앞서 말했듯이 선형성은 비용이 비싸다. 

좋은 소식은 절충이 가능하다는 것이다. 선형성은 인과성을 유지하는 **유일한 방법은 아니고** 성능 손해를 유발하지 않고도 인과적 일관성을 유지할 수 있다. 이 연구는 현재 계속 진행되고 있다. 

#### 인과적 의존성 담기 
이 인과적 의존성의 핵심 아이디어만 살펴본다. 인과성을 유지하기 위해서는 어떤 연산이 어떤 다른 연산보다 먼저 실행되었는지 알아야한다. 인과적 의존성을 결정하려면 시스템 노드에 있는 지식을 기술할 방법이 필요하다. 노드가 쓰기 y를 실행했을 때 값 x를 본 상황이라면 x, y는 인과적 관련이 있을 지 모른다. 이 분석은 범죄 수사와도 같은 질문을 사용한다. 'y라는 결정을 한 당시에 x에 대해 **알았을까?**'

인과적 순서를 결정하기 위해서 DB 는 애플리케이션이 데이터의 어떤 버전을 읽었는지 알아야한다. 트랜잭션이 커밋을 원할 때 DB 는 읽은 데이터의 버전이 최신인지 확인한다. 이런 목적으로 DB는 어떤 데이터를 어떤 트랜잭션이 읽었는지 추적한다. 

### 일련번호 순서화
하지만 모든 인과적 의존성을 추적하는 것은 실용성이 떨어진다.(오버헤드가 큼) 대신, 일련번호나 타임스탬프를 써서 이벤트의 순서를 정할 수 있다. 타임스탬프는 논리적 시계에서 얻어도 되고, 보통 모든 연산마다 증가하는 카운터를 사용한다. 이 일련번호나 타임스탬프는 크기가 작고, 전체 순서를 제공한다. 전체순서 -> 부분 순서도 제공하니, 인과성에 일관적일 수 있다.

#### 비인과적 일련번호 생성기 
하지만 단일리더가 없다면 일련번호를 어떻게 생성할까? 현실에서는 다양한 방법을 사용한다.

- 각 노드가 자신만의 독립적인 일련번호 집합을 사용한다. 예를 들어 노드 두대이면 하나는 홀수, 하나는 짝수. 일반적으로는 일련번호의 몇 비트를 사용해서 노드 식별자를 포함한다.
- 각 연산에 wallclock time을 사용할 수 있다. 이 타임스탬프는 순차적이지 않지만 해상도가 충분히 높다면 연산의 전체순서를 정하는데 충분할 수도 있다. 이는 최종쓰기승리 충돌해소법에서 사용한다.
- 일련번호 블록을 미리 할당할 수 있다. 노드A는 1~1000까지, B는 1001부터~ 2000까지라는 식이다. 번호 비축량이 낮아지면 새 블록을 할당한다. 

위 세가지는 잘 동작하지만, 문제가 있다. 생성한 일련번호가 인과성에 일관적이지 않다. 
1) 각 노드는 초당 연산수가 다를수있다. 따라서 한 노드가 짝수를 생성하고 다른 노드가 홀수라면, 짝수용 카운터가 뒤처지거나 너무 앞지를 수 있다. 
2) 물리적 시계에서 얻은 타임스탬프는 인과성에 일관적이지 않을 수 있다. 
3) 블록 할당자의 경우 인과적으로 나중에 할당되는 연산이 1-1000  블록을 받을 수도 있다. 
  
#### 램포트 타임스탬프
위 문제를 해결한 타임스탬프가 실제로 있다. 이 방법은 램포트 타임스탬프라고하고, 분산시스템에서 가장 많이 인용된 논문 중 하나다. 

![lamport timestamp](./7.png)

각 노드는 고유 식별자를 갖고, 각 노드는 처리한 연산 갯수를 카운터로 유지한다. 램포트 타임스탬프는 그냥 (카운터, 노드ID)의 쌍이다. 

이는 물리적 시계와 아무 관련이 없지만, 전체 순서화를 제공한다. 두 타임스탬프가 있으면 카운터가 큰 것이 타임스탬프가 크다. 카운터 값이 같으면 노드 ID가 큰것이 타임스탬프가 크다. 

핵심 아이디어는 이것이다. 모든 노드와 모든 클라이언트가 지금까지 본 카운터 값 중 최댓값을 추적하고 모든 요청에 그 최댓값을 포함시킨다. 노드가 자신의 카운터보다 큰 값을 받으면 바로 자신의 카운터를 그 값으로 올린다. 

#### 타임스탬프 순서화로는 충분하지 않다

램포트 타임스탬프가 전체순서를 정의해주긴하지만, 분산시스템의 공통 문제를 해결하기엔 부족하다. 

예를 들어 유니크한 유저네임을 갖도록 보장하는 시스템을 고려해보자. 두 사용자가 동시에 같은 이름으로 만들려고 하면 하나는 성공하고 하나는 실패한다. 사용자가 둘다 생성된 이후에 타임스탬프로 하나를 실패하게 할 수는 있다. (사후 처리) 그러나 노드가 사용자로부터 유저네임 생성 요청을 받고 그 요청을 당장 성공/실패 처리해야하는 경우라면 이 노드는 다른 노드가 같은 유저네임 생성을 하고 있는지, 어떤 타임스탬프를 배정받았는지 알지 못한다.  

이를 알기 위해서는 다른 모드 노드가 뭘하고 있는지 확인해야한다. 이를 구현하면 한 노드만 장애가 생겨도 시스템이 멈추게 된다. 이는 내결함성 위반이다. 

즉 문제는 전체 순서가 모든 연산을 모은 이후에 드러난다는 것이다. 그러므로 유일성 제약 조건 같은 것을 구현하려면 전체 순서로 충분하지 않다. `언제 전체순서가 확정되는지`도 중요하다.

### 전체순서 브로드캐스트 
위에서 언제 전체순서가 확정되는지에 대한 아이디어를 이야기했다. 프로그램이 단일 CPU 코어에서 실행된다면 연산의 전체 순서를 정하기 쉽다. 하지만 분산 시스템에서는 위와 같이 타임스탬프나 일련번호를 이용할 수 있지만, 문제가 있다는 것을 발견했다.  

단일 리더 복제의 단일 코어에서 일을 하다가, 처리량이 급증할 때 시스템을 확장하고 리더에 장애가 발생했을 때 어떻게 할 것인가의 문제를 **전체 순서 브로드캐스트**라고한다. 이는 노드 사이에 메시지를 교환하는 프로토콜로 기술된다. 

- 신뢰성 있는 전달
  - 어떤 메시지도 손실되지 않는다. 한 노드에만 메시지가 전달되면 모든 노드에도 전달
- 전체 순서가 정해진 전달
  - 메시지는 모든 노드가 같은 순서로 전달된다. 

전체 순서 브로드캐스트를 구현하는 올바른 알고리즘은 위 두 조건을 항상 만족해야한다. 

#### 전체 순서 브로드캐스트 사용하기 
주키퍼나 etcd와 같은 합의 서비스는 전체 순서 브로드캐스트를 실제로 구현한다. 즉, 전체순서브로드캐스트 <-> 합의 간 강한 연관이 있다는 암시이다. 

전체 순서 브로드 캐스트는 복제에 필요한 것이다. 모든 메시지가 DB에 쓰기를 나타내고, 모든 복제 연산이 같은 순서로 처리하면 복제 서버들은 서로 일관성 있는 상태를 유지한다. 이 원리를 상태 기계 복제라고한다. (state machine replication)

마찬가지로 전체 순서 브로드캐스트를 직렬성 트랜잭션을 구현하는데도 쓸 수 있다. 모든 메시지가 스토어드 프로시저*로 실행되는 결정적 트랜잭션을 나타낸다면, 그리고 모든 노드가 이를 순서대로 처리한다면 데이터베이스의 파티션과 복제본은 서로 일관적인 상태를 유지한다.

* 스토어드 프로시저:DB 내부에 저장된 일련의 SQL 명령문들을 하나의 함수처럼 실행하기 위한 쿼리의 집합 (까먹어서 다시 적기)

중요한 측면은 전체 순서 브로드캐스트는 메시지가 전달되는 시점에 그 순서가 고정된다는 것이다. 나중에 도착된 메시지가 중간에 끼어들거나 소급적용되는것이 없다. 이때문에 앞서 말한 타임스탬프 순서화보다 강하다. 

다른 관점에서 보면 전체 순서 브로드캐스트는 로그를 만드는 방법과도 비슷하다. ㄸ한 펜싱 토큰을 제공하는 잠금 서비스를 구현하는데도 유용하다. 잠금을 획득하는 모든 요청은 메시지로 로그에 추가되고, 모든 메시지는 로그에 나타난 순서대로 일련번호가 붙는다. (일련번호는 단조 증가하므로 펜싱 토큰의 역할을 할 수 있다.) 주키퍼에서는 이를 zxid라고 한다. 

#### 전체 순서 브로드캐스트를 사용해 선형성 저장소 구현하기 
전체 순서 브로드캐스트는 비동기식이다. 메시지는 고정된 순서로 신뢰성 있게 전달되지만 언제 전달될지는 보장되지않는다. 선형성은 최신성 보장이다. 읽기가 최근에 쓰여진 값을 보는게 보장된다. 

그러나 전체 순서 브로드캐스트 구현이 있다면 이를 기반으로 한 선형성 저장소를 만들 수 있다. unique constraint 예제를 보자. 

모든 사용자 명마다 원자적 compare and set 연산이 구현된 선형성 저장소를 가질 수 있다고 상상해보자. 모든 레지스터는 초기에 null이다 (점유되지 않음). 사용자명을 생성할 때 null 인 경우만 set할 수 있도록 한다. 선형성때문에 여러 유저가 같은 사용자명을 가지려고하면 compare-and-set 연산 중 하나만 성공한다. 

전체 순서 브로드캐스트를 추가 전용 로그로 사용해 선형성 compare-and-set 연산을 다음과 같이 구현할 수 있다. 
- 메시지를 로그에  추가해서 점유하기 원하는 사용자명을 시험적으로 가리킨다
- 로그를 읽고, 추가한 메시지가 되돌아오기를 기다린다.
- 원하는 사용자명을 점유하려고하는 메시지가 있는지 확인한다. 본인이 첫 메시지라면 성공이다. 다른 사용자가 보낸 메시지라면 연산을 어보트 시킨다. 

로그 항목은 모든 노드에 같은 순서로 전달되므로 여러 쓰기가 동시에 실행되면 모든 노드가 어떤 쓰기가 먼저 실행된 것인지 동의한다. 

이 절차는 선형성 쓰기를 보장하지만, 선형성 읽기는 보장하지않는다. 로그로부터 비동기로 갱신되는 저장소를 읽으면 오래된 값이 읽힐 수 있다.  읽기를 선형적으로 
만들려면 몇가지 선택지가 있다. 

- 로그를 통해 순차 읽기를 할 수 있다. 로그에 메시지를 추가하고 로그를 읽어서 메시지가 되돌아왔을 때 실제 읽기를 수행하면 된다. 따라서 로그상의 메시지 위치는 읽기가 실행된 시점을 나타낸다. 

- 로그에서 최신 로그 메시지의 위치를 선형적 방법으로 얻을 수 있다면 그 위치를 질의하고 그 위치까지의 모든 항목이 전달되기를 기다린 후 읽기를 수행할 수 있다.
  
- 쓰기를 실행할 때 동기식으로 갱신돼서 최신이 보장되는 복제 서버에서 읽을 수 있다. 

#### 선형성 저장소를 이용해 전체 순서 브로드캐스트 구현하기 
전체 순서 브로드캐스트 -> 선형성 저장소 만들기 뿐 아니라 반대로도 구현할 수 있다. 
가장 쉬운 방법은 정수를 저장하고 원자적 increment-and-get연산이 지원되는 선형성 레지스터가 있다고 가정하는 것이다. 

알고리즘은 간단하다. 전체 순서 브로드캐스트를 통해 보내고 싶은 모든 메시지에 대해 선형성 정수로 increment-and-get 연산을 수행하고 레지스터에서 얻은 값을 일련번호로 메시지에 붙인다. 그 후 메시지를 모든 노드에 보낼 수 있고 수신자들은 일련번호 순서대로 메시지를 전달한다. 

실패가 없다면 이 방법은 제대로 동작한다. 메시지 4를 전달하고, 일련번호가 6인 메시지를 받았다면 5를 기다려야한다는 것을 알 수 있다. 문제는 노드에 장애나 네트워크 오류가 발생했을 때 일어난다. 이렇게 일련번호 생성에 대해서 고민하다보면 필연적으로 합의 알고리즘에 도달하게 된다. 이는 우연히 아니다. 선형성 레지스터 <-> 전체 순서 브로드캐스트 <-> 합의는 동등한 것으로, 하나의 해결책을 다른 하나로 변형할 수 있다.

## 분산 트랜잭션과 합의 

### 원자적 커밋과 2단계 커밋 
### 현실의 분산 트랜잭션 
### 내결함성을 지닌 합의 
### 멤버십과 코디네이션 서비스 
