---
title   : '로드맵 파헤치기' 
slug  : '/roadmap-digging'
layout  : wiki 
excerpt : 
date    : 2020-12-31 17:12:58 +0900
updated : 2020-12-31 17:18:52
tags    : 
---

## 서론 
roadmap 을 보면서, 내가 아는 것도 어렴풋이 알고 있고 모르는 건 아주 화끈하게 모른다는 점을 알게 되었다. 

머릿속에 정리가 안되는 찜찜한 상태로 있기 보다는, 일단 위키를 만들어서 써내려가기로 했다. 


### 인터넷이 무엇인가요? 
레퍼런스 없이 생각해봤을 때.. internet 이라는 이름부터 파고 들어보자. internet, net 은 여기서 network 이다. 네트워크는 노드와 엣지로 이루어져 정보를 교환하는 '망'을 의미한다.(net) inter-net 은 이 네트워크끼리 소통하는 더 커다란 의미의 네트워크를 의미한다고 볼 수 있다. 

소비자 입장에서 생각해보면 인터넷은 타인의 노드(device)에 브라우저를 통해서 자유롭게 접근하는 망을 의미한다. 이 노드 간 연결은 어떻게 되냐고? 레이어를 쭉 타고 내려가야겠지만 일반적인 인터넷 연결은 TCP-IP를 지나... 노드간에 전송인 transport layer? - data layer - physical layer 까지 거쳐서 정보를 전송한다. 


### Spring이 무엇인가요? 
스프링은 복잡한 엔터프라이즈 애플리케이션을 효과적으로 개발하기 위한 기술이다. 

### JavaBean 
아래 두가지 관례에 따라 만들어진 오브젝트
- 디폴트 생성자: 자바빈은 파라미터가 없는 디폴트 생성자를 갖고 있어야 한다. 툴이나 프레임워크에서 리플렉션을 이용해 오브젝트를 생성하기 때문에 필요하다.
- 프로퍼티: 자바빈이 노출하는 이름을 가진 속성. getter, setter

### Spring의 Bean, BeanFactory
- 빈 :  스프링 컨테이너가 생성, 관계설정, 사용 등을 제어해주는 제어의 역전이 적용된 오브젝트
- 빈팩토리:  빈 생성, 관계설정 같이 제어를 담당하는 IoC 오브젝트
- application context : 빈 팩토리를 확장한 IoC 컨테이너, 빈 팩토리의 기능 + 스프링이 제공하는 각종 부가 서비스를 추가로 제공
빈 팩토리라고 부를 때는 주로 빈 생성과 제어의 관점, 애플리케이션 컨텍스트라고 할 떄는 스프링이 제공하는 애플리케이션 지원 기능을 포함하는 것
ApplicationContext는 BeanFactory를 상속

### 상속이 반드시 좋은 방법이 아닌 이유 
상속을 통한 상하위 클래스의 관계는 생각보다 밀접해있어 다른 관심사 간 긴밀한 결합을 허용한다.
상속을 통해 만들어진 구현체가 중복을 발생시킬 수 있다.

### IoC (Inversion of Control) 
제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 즉 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않는다! 당연히 생성하지도 않는다. 모든 제어 권한을 다른 대상에게 위임하기 때문이다. 예를 들어, 서블릿을 개발해서 서버에 배포할 수 있지만 서블릿의 실행을 직접 제어할 수 있는 방법은 없다.
프레임워크도 제어의 역전 기술이 적용된 대표적인 기술이다. 흔히 라이브러리와 혼동하고는 하는데, 큰 잘못이다. 우리는 라이브러리를 능동적으로 사용한다. 반면 프레임 워크는 거꾸로 애플리케이션 코드가 프레임워크에 의해 사용된다.
즉 우리는 스프링 없이도 작은 IoC 프레임워크를 사용한 셈이다. 제어의 역전에는 프레임워크 혹은 컨테이너와 같이 애플리케이션 컴포넌트의 생성과 관게설정, 생명주기 관리 등을 관장하는 존재가 필요하다. 단순한 적용이면 우리의 예제로 충분하지만, 애플리케이션 전반에 IoC를 사용하고 싶다면 스프링과 같은 IoC 프레임워크의 도움을 받는 편이 유리하다. 🦦

### Singleton 
어떤 클래스를 애플리케이션 내에서 제한된 인스턴스 개수(1개)만 존재하도록 강제
private 생성자를 갖고 있기 때문에 상속할 수 없다
객체지향의 장점인 상속과 이를 이용한 다형성을 적용할 수 없다. 기술적인 서비스만 제공하는 경우라면 상관없지만 애플리케이션 로직을 담고 있는 일반 오브젝트의 경우 싱글톤이 되면 객체지향의 장점을 적용하기 어렵다.
싱글톤은 테스트하기 힘들다(큰 단점)
싱글톤으로 되어 있어 테스트할때 mock 오브젝트로 대체하기 힘들기 때문에 직접 다 만들어서 사용할 수 밖에 없는데 이런 경우 테스트 오브젝트로 대체하기 어렵다.
서버 환경에서는 싱글톤이 하나만 만들어지는 것을 보장하지 못한다.
클래스 로더를 어떻게 구성하고 있느냐에 따라 싱글톤 클래스임에도 하나 이상의 오브젝트가 생길 수 있음. 여러 JVM에 분산되어 설치되는 경우에도 각각 독립적으로 오브젝트가 생기기 때문에 싱글톤으로서의 가치가 떨어짐
싱글톤의 사용은 전역 상태를 만들 수 있기 때문에 바람직하지 못하다
싱글톤은 사용하는 클라이언트가 정해져있지 않고 스태틱 메서드로 언제든지 접근할 수 있기 때문에 자연스럽게 전역 상태로 사용되기 쉽다. 아무 객체나 자유롭게 접근하고 수정하고 공유할 수 있는 것은 객체지향 프로그래밍에서는 권장되지 않는 모델이다.
템플릿 메소드 패턴
