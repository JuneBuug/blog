---
title   : '[데이터중심어플리케이션설계] 5장. replication' 
slug  : '/data-intensive-05'
layout  : wiki 
excerpt : 
date    : 2020-11-09 16:17:06 +0900
updated : 2020-11-09 17:14:45
tags    : 
 - Data Intensive Application
 - Data Structure
---

## Part 2. Distributed Data
파트 2에서는 '여러 머신이 저장과 데이터 접근에 관여하게 되면 어떤 일이 일어날까?' 라는 질문에 대답하게 됩니다. 

왜 분산 시스템을 구축하게 될까요? 

- Scalability 
  - 데이터의 크기, 읽기/ 쓰기 부하가 한 머신이 다룰 수 있는 것 이상으로 커지면, 여러 머신에 부하를 나누는게 합리적입니다. 
    
- Fault tolerance / high availablity 
  -  한 머신이 다운되어도 서비스가 돌아가게 하려면, 여러 머신을 사용해서 중복을 제공해야합니다. 하나가 죽어도 다른 하나가 보완할 수 있게요. 
     
- Latency 
  - 만약 서비스 자체가 글로벌 대상이라면, 대상 지역과 가까운 데이터 센터를 사용하길 원할 수 있습니다. 가까울 수록 지연은 짧아집니다. 
    
### 메모리 공유 / 디스크 공유 / 공유 안하는 구조 
- shared memory 
  - 하나의 머신에 CPU / RAM / DISK 를 최대한 많이 고성능으로 넣는 구조 
  - 비용이 많이든다. 두배의 CPU 는 두배 이상의 가격
  - 가용성이 떨어짐. 하이엔드머신이면 컴포넌트를 교환할 수 있지만, 여전히 지리적으로 한 군데만 있다는 점. 

- shared disk 
  - 여러 머신(독립된 CPU / RAM), 공유된 디스크(네트워크로) 
  - 데이터 웨어하우스에서 사용되는 케이스가 있음
  - 경합이나 lock 오버헤드 때문에, 확장성이 떨어짐 
    
- shared-nothing  
  - 가장 선호되는 구조.
  - 각 머신(이나 VM) 은 node라고 불림. 각 노드는 개별의 CPU, RAM, disk가 있고, 노드간 연결은 소프트웨어 레벨에서 연결됨. 
  - 특별한 하드웨어가 필요하지않으므로, 가성비가 좋음. 여러 지리적 위치에 분배해서 지연을 늦출 수 있음
  - 장점이 많긴하지만, 어플리케이션에 복잡성을 유발할 수 있고 데이터모델의 표현성이 제한될 수 있음. 어떤 경우는 싱글스레드 프로그램이 100 CPU 코어가 넘는 클러스터보다 성능이 좋은 경우도 있음.
  - 파트 2에서 주로 다룸

## 5장. Replication

복제(Replication)은 **같은 데이터의 복제본을 네트워크로 연결된 여러 머신에 나눠서 보관하는 일**을 말함. 

복제를 하는 이유! 
- 위에서 말했듯, 유저에게 지리적으로 가까운 위치에 데이터를 두기 위해 (그래서 지연을 줄임)
- 하나의 머신이 죽어도 다른 머신이 보완 (그래서, 가용성을 높임)
- 읽기 쿼리를 수행할 수 있는 머신을 늘려서, 읽기 throughput 을 높이기 위함 

여기서는 하나의 머신이 모든 데이터 복사본을 수용할 수 있을 정도로 데이터가 작다고 가정한다. 
 
데이터가 변하지 않으면 복제는 너무나 쉽겠지만, 현실에서 데이터는 계속 변한다. 여기서는 대표적인 복제 방식인 single-leader, multi-leader, leaderless 세 가지 방식을 알아본다. 

복제를 할 때 결정해야할 것들이 몇가지가 있다. 
- sync ? async?
- replica 가 실패했을 때 다루는 방법
- DB 설정 .. 

이 사항들을 결정했을 때 생기는 결과를 이번 챕터에서 알아보자.  

> eventual consistency (결과적 일관성) : 잠시 데이터가 일관적이지 않아도, 결국에는 맞춰진다. 이 부분에 대해 많은 토론이 있는데, 이 부분에 대해서도 이후에 언급하겠다. 

### Leader / Followers 
DB의 복제본을 저장하고 있는 노드를 **replica** 라고 한다. 여러 replica가 있으면, 필연적으로 다음 의문이 생긴다. '어떻게 모든 레플리카가 갖고 있는 데이터가 동일하다고 보장할 수 있는가?'

DB에 매번 쓰기가 일어나면, replica도 동일하게 쓰기가 일어나야한다. 그렇지 않으면, replica에는 동일한 데이터가 없게된다. 이를 해결하는 가장 흔한 방법이 
**leader 중심 복제** 이다.

leader 중심 복제는 다음과 같이 작동한다. 

