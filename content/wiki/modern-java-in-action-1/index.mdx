---
title   : '모던자바인액션 1장, 2장, 3장' 
slug  :  '/modern-java-1'
layout  : wiki 
excerpt : 
date    : 2020-06-26 15:25:52 +0900
updated : 2020-06-26 17:40:20 +0900
tags    : 
---

## 1장 자바 8,9,10,11 : 무슨일이 일어나고 있는가? 

자바8는 자바 버전을 통틀어서 가장 큰 변화다. 자바 8 이전의 대부분 프로그램은 멀티코어 머신에서도 하나의 코어만을 지원했다. 나머지 코어를 활용하려면 **스레드**를 활용하는 것이 일반적인 방법이었다. 하지만 스레드는 관리하기가 어렵고, 많은 문제가 발생할 수 있다는 단점이 있다. 

이 부분을 보완하기 위해서 자바는 다양한 방식으로 발전해왔다. 1 버전에서는 스레드, 락, 메모리 모델까지 지원했고, 자바 5에서는 스레드 풀, 자바 7에서는 포크/조인 프레임워크를 제공했다. 그러기를 반복해 자바 8에서는 이런 병렬 실행을 효율적으로 하는 방법을 알아냈다. 

- 스트림 API
- 메서드에 코드를 전달하는 기법(메서드 참조, 람다)
- 인터페이스의 디폴트 메서드

자바 8은 병렬 연산을 지원하는 **스트림**이라는 새로운 API 를 제공한다. 우리가 SQL 을 사용하면 DBMS에서 알아서 최적의 실행계획을 짜주는 것처럼, 스트림 역시 최적의 병렬 실행 방법을 알아서 선택해준다. 

그러면 메서드에 코드를 전달하는 기법이 왜 중요한가? 이를 위해서는 자바의 배경을 간략하게 짚고 넘어가야한다. 

자바는 대중적이고 잘 설계된 객체지향 언어로 시작했다. 캡슐화 덕분에 C에 비해 엔지니어링적인 문제가 훨씬 적었고, 객체지향이라는 정신적 모델 덕분에 윈도우 95 및 그 이후의 프로그래밍 모델에 쉽게 대응할 수 있었다. 또한 write-once, run-everywhere를 지원하는 JVM 언어의 특징도 있었다. 

하지만 생태계에 변화가 생겼다. 프로그래머는 빅데이터를 맞이하면서, 멀티코어나 컴퓨팅 클러스터를 이용해서 **많은 양의 데이터를 효과적으로** 처리해야할 필요성이 늘었다. 이런 생태계에서 자바는 어떻게 대응해야했을까? 

자바 8은 세가지 개념을 사용해서 이런 현상을 대응하고, 시장에서 요구하는 기능을 효과적으로 제공한다. 

### 스트림 처리 

첫번째 프로그래밍 개념은 스트림 처리다. **스트림**이란 한번에 한개씩 만들어지는 연속적인 데이터 항목들의 모임이다. 이론적으로, 프로그램은 입력 스트림에서 데이터를 하나씩 읽어 들이며 마찬가지로 출력 스트림으로 데이터를 한 개씩 기록한다. 

스트림의 처리 방식은 자동차 생산라인에 비유할 수 있다. 각 작업장에서는 자동차를 받아서 작업한 뒤, 다음 작업장에서 처리할 수 있도록 넘겨준다. 컨베이어 벨트 자체는 자동차를 물리적인 순서로 **한개씩 운반** 하지만, 각각의 작업장에서는 **동시에 작업을 처리한다**. 

우선은 자바의 Stream API 역시, 컨베이어 벨트 조립 라인처럼 어떤 항목을 연속으로 제공하는 기능이라고 생각하자.  핵심은 기존에는 한번에 한 항목을 처리햇찌만 이제 자바8에서는 우리가 하려는 작업을 추상화해서, 일련의 스트림으로 만들고 처리할 수 있다는 것이다. 또한 스트림 파이프라인을 사용해서 입력 부분을 여러 CPU 코어에 쉽게 할당할 수 있다는 부가적인 이득도 얻을 수 있다. 스레드라는 복잡한 작업을 사용하지 않고도 공짜로 병렬성을 얻을 수 있다. 

### 동작 파라미터화로 메서드에 코드 전달하기

두번째 개념은 코드 일부를 API로 전달하는 기능이다. 예를 들어 sort를 생각해보자. 2020KR0001, 2019US0002, ... 등의 송장 ID가 있다고 생각해보자. 이는 세가지 방법으로 sort할 수 있다. 처음 부분인 연도, 그다음 부분인 나라, 그다음 부분인 고객ID로 말이다. sort의 동작은 이렇게 구체적이지 않으므로 원하는 대로 정렬하도록하려면 sort에 따로 코드를 제공해야한다. 

자바 8에서는 메서드를 다른 메서드의 인수로 넘겨주는 기능을 제공한다. (즉 함수가 first citizen으로서 기능함) 이 기능을 이론적으로 **동작 파라미터화**라고 부른다. 

### 병렬성과 공유 가변데이터 

세번째 개념은 '병렬성을 공짜로 얻을 수 있다'는 말에서 시작된다. 그럼 우리는 병렬성을 얻는 대신 무엇을 포기해야할 까? 스트림 메서드로 전달하는 코드의 동작 방식을 바꿔야한다. 스트림 메서드로 전달될 수 있는 코드는 다른 코드와 동시에 실행하더라도 **안전하게 실행될 수 있어야한다**. 

안전한 코드를 만들려면 공유된 가변 데이터에 접근하지 않는 함수여야한다. 이런 함수를 순수 함수(= 부작용 없는 함수, 상태 없는(stateless) 함수) 라고 부른다. 하지만 공유된 변수가 객체가 있는 상태에서는 문제가 발생한다. 

가변데이터를 공유하지 않는 것, 그리고 메서드를 다른 메서드로 넘기는 기능 이 두 가지는 함수형 프로그래밍 패러다임의 핵심이기도 하다.

## 자바 8에 추가된 새로운 개념들 살펴보기 💪

### 자바 함수 

자바 8 이전까지 자바의 일급시민은 객체였다. 프로그래밍 언어의 핵심은 값을 바꾸는 것이고, 이 바꿀수 있는 값은 일급시민이라고 부른다. 자바에서 바꿀 수있는 값은 primitive type인 int, double 그리고 **객체**이니까. 전달하고 (메서드의 파라미터로서) 변경할 수 없는 값은 이급시민이다. 

그러므로 오랫동안 객체와 기본값은 자바에서 일급시민이엇지만 메서드와 클래스 등은 이급 시민이었다. 자바 8 설계자들은 런타임에 메서드를 전달하여 (메서드의 일급 시민화) 사용한다면 유용하다는 점을 깨닫고 그런 기능을 추가했다. 

#### 메서드와 람다를 일급 시민으로

이를 위한 첫번째 기능은 **메서드 참조** 이다. 디렉터리에서 모든 숨겨진 파일을 필터링한다고 가정하자. File 클래스는 isHidden 메서드를 제공한다.  

```java
// 자바 8이전
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
     public boolean accept(File file) {
        return file.isHidden();
     }
})
```

자바 8이전에는  이미 File에 isHidden 메서드가 있는데도 FileFilter를 사용해서 복잡하게 감싸서 사용해야했다. 

```java
// 자바 8 이후 
File[] hiddenFiles = new File(".").listFiles(File::isHidden); 
```

`::` 라는 자바의 메서드 참조를 이용해서 준비된 함수를 전달했다. 기존에 비해 문제를 명쾌하게 설명한다는 것이 자바8 코드의 장점이다. 

**람다:익명함수** 역시 메서드 일급 시민만들기의 일부이다. 메서드를 직접 정의할 수 도 있지만, 당장 쓸만한 클래스나 메서드가 없을 때 익명함수인 람다를 간단하게 구현할 수 있다. 람다는 다음과 같은 형식을 띈다. 
```java
(int x) -> x + 1 
```

#### 코드 넘겨주기의 예제 

코드를 넘겨준다, 즉 메서드를 일급시민으로 취급하는 예제를 살펴보자. 

사과 클래스가 있다. 그리고 두가지 일을 하고 싶다. 

- 초록 사과만 분류하고싶다. 
- 무게가 150g이 넘는 사과만 분류하고 싶다. 
  
여기에서 초록사과, 무게가 150g이 넘는 사과는 조건에 해당한다. 분류하는 작업, 다시 말해 특정 항목을 선택해서 반환하는 동작은 필터(filter) 라고한다. 만약 코드 넘겨주기가 없다면 우리는 사과 클래스 안에 두가지 메소드를 만들어야할 것이다. 

```java
public static List<Apple> filterGreenApples(List<Apple> inventory)  {
    List<Apple> result = new ArrayList<>(); 
    // 새로운 리스트 결과에 green apple만 add하는 코드
}

public static List<Apple> filterHeavyApples(List<Apple> inventory)  {
    List<Apple> result = new ArrayList<>(); 
    // 새로운 리스트 결과에 Heavy Apple만 add하는 코드
}
```
이렇게 반복되는 코드를 작성하다보면...  견딜 수 없는 수준에 이른다 😭. 다행히 자바 8에서는 코드를 인수로 넘겨줄 수 있으므로 filter 부분을 중복으로 구현할 필요가 없다.  

```java
public static boolean isGreen(Apple apple) {
 return GREEN.equals(apple.getColor());
}

public static boolean isHeavy(Apple apple) {
 return apple.getWeight() > 150;
}

static List<Apple> filter(List<Apple> inventory, Predicate<Apple> p) {
   List<Apple> result = new ArrayList<>();
   // 조건 p 에 맞는 사과만 result에 add
}
```
Predicate는 수학에서 인수로 값을 받아 boolean을 반환하는 함수를 말한다. Function<T, Boolean> 과 같은 개념이다. (T는 임의의 타입) 

#### 메서드 전달에서 람다로 

위의 isHeavy나 isGreen은 한두번만 사용될 메소드이다. 이를 매번 정의하는 것은 귀찮은 일이다. 이를 람다로 치환하여 사용할 수 있다. 

```java
filter(inventory, (Apple a) -> GREEN.equals(a.getColor());
```
즉 한번만 사용할 메서드는 따로 정의를 구현할 필요가 없다. 다만, 람다가 몇 줄 이상으로 길어진다면 이름을 가진 메서드를 정의하고 메서드 참조를 활용하는 방향이 바람직하다.

위에서는 직접 정의한 filter 메서드를 사용했지만, 자바 8은 스트림 API 내부에 filter 와 비슷한 연산 집합을 포함하는 기능을 제공한다. 스트림을 한번 살펴보자. 

### 스트림 

거의 
