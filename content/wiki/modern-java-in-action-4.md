---
title   : '모던자바인액션-CompletableFuture' 
slug  :  '/modern-java-4'
layout  : wiki 
excerpt : 
date    : 2020-07-14 14:03:46 +0900
updated : 2020-07-14 14:43:44
tags    : 
---

# 15장 CompleteableFuture와 리액티브 프로그래밍 컨셉의 기초 
  
소프트웨어 개발방법은 나날이 발전하고 있다. 그 중에서도  뚜렷하게 보이는 추세는 이 두가지이다.

- 멀티코어 프로세서의 발전
  - 멀티코어 프로세서가 발전하면서, 이를 가장 **잘 활용**하도록 소프트웨어를 개발하는 경향이 늘어났다. 포크/조인, 그리고 병렬 스트림이 이 경향을 반영한다.
  
- 애플리케이션 구성 방법 
  - 예를 들면, 마이크로서비스 (<-> 모놀리틱) 아키텍처의 선택이 늘어났다. 하나의 거대한 서비스 대신 작은 서비스로 애플리케이션을 나누고, 서비스 간 **통신**하여 정보를 주고 받고록 했다. 따라서 앞으로 어플리케이션은 여러 소스에서 정보를 가져와서 합치는 매시업 형태가 되어가고 있다. 
    
이런 애플리케이션을 구현하려면 네트워크(인터넷)을 통해서 여러 웹 서비스에 접근해야한다. 그러나 서비스의 응답을 기다리는 동안 연산이 블록되거나, CPU 클록 사이클 자원을 낭비하는 것이 우리가 바라는 바는 아니다 😭 

이 점에서 멀티태스크 프로그래밍의 양면성이 돋보인다. 7장에서의 포크/조인 그리고 병렬 스트림은 병렬성의 귀중한 도구다. 하지만 병렬성이 아니라 동시성이 필요한 상황, 즉, 조금씩 연관된 작업을 같은 CPU에서 동작하는 것이 목표라면 원격 서비스나 데이터베이스 결과를 기다리는 스레드를 블록해서 자원을 낭비하지는 말아야한다. 

앗, 그런데 동시성과 병렬성이 헷갈린다. 동시성은 단일 코어 머신에서 발생할 수 있는 프로그래밍 특성으로, 실행이 서로 겹치는 경우가 있다. 반면 병렬성은 하드웨어 수준에서 다른 코어에서 작업이 도는 것을 의미한다. 

자바는 동시성 환경에서 사용할 수 있는 주요 도구를 두가지 제공한다. 

- Future 인터페이스. 자바8의 CompletableFuture를 사용

- 자바9의 pub-sub 프로토콜, 그리고 리액티브 프로그래밍에 기반한 Flow API 
  
여기서는 `CompletableFuture`에 대한 내용을 먼저 살펴보자. 

## 15.1 동시성을 구현하는 자바 support의 진화

자바에서의 동시성 프로그래밍은 계속 발전해왔다. 처음에 자바는 Runnable과 Thread를 동기화된 클래스와 메서드를 이용해서 lock 했다. 2004년, 자바 5는 ExecutorService 인터페이스, 그리고 Runnable과 Thread 등을 반환하는 `Callable<T>`, `Future<T>`, 제네릭 등을 지원하기 시작했다. ExecutorService는 Runnable과 Callable을 둘다 실행할 수 있다. 이런 기능이 생겨서, 멀티코어 CPU 에서 쉽게 병렬 프로그래밍을 구현할 수 있게되었다. 

멀티코어 CPU에서 더 효율적으로 프로그래밍할 이유가 생기면서, 이후 자바에서는 동시성 지원이 더 개선되었다. 자바 7에서는 divide-and-conquer 즉 포크-조인을 지원하는 RecursiveTask가 추가되었고 자바8에서는 스트림, 람다를 기반으로한 병렬 처리가 추가되었다. 

자바는 Future를 조합할 수 있는 기능을 추가하면서, 동시성을 강화했다. (CompletableFuture). 자바8에서는 분산 비동기 프로그래밍을 명시적으로 지원했다. 이 API들은 매쉬업 어플리케이션을 개발하는데 필수적인 모델과 toolkit을 지원한다. 이 과정을 **리액티브 프로그래밍** 이라고 부른다. 자바 9에서는 pub-sub 프로토콜로 이 과정을 추가 지원한다. 

### 15.1.1 스레드와 높은 수준의 추상화 

운영체제 시간에 배웠을 테지만, 단일 CPU 에서도 여러 사용자가 존재할 수 있다. 이는 OS 가 각 사용자에 프로세스 하나를 할당하기때문이다. OS는 두 사용자가 각각 자신만의 공간에 있다고 생각할 수 있도록 가상 주소 공간을 각 프로세스에 제공한다. [참고 - 가상메모리](https://velog.io/@pa324/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C-%EA%B0%80%EC%83%81-%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B0%9C%EB%85%90-4dk2q3ivff) 프로세스는 다시 OS에, 스레드 (자신과 같은 주소공간을 공유하는 프로세스) 를 요청하여, task를 동시에 혹은 협력하여 사용이 가능하다. 

멀티코어인 경우, 스레드의 도움이 없이는 컴퓨팅 파워를 모두 활용할 수 없다. 각 코어는 한개 이상의 프로세스는 스레드에 할당되지만, 프로그램이 스레드를 사용하지 않는다면 효율성을 고려해 코어 하나만 사용할 것이다. 

앞서 말했던 것 처럼 스트림을 사용해서 스레드의 사용을 **추상화** 할 수 있다.
즉
```java
long sum0 = 0; 
for (int i=0; i<250_000; i++) {
  sum0 += stats[i];
}
```
위와 같은 코드를 실행하는 네개의 스레드를 관리하는 코드가 있다면, 

```java
sum = Arrays.stream(stats).parallel().sum(); 
```
으로 쉽게 변경할 수 있다. 

스레드 추상화를 더 살펴보기전에, 기초에 해당하는 자바 5의 ExecutorService 개념과 스레드 풀을 알아보자. 

### 15.1.2 Executor와 스레드 풀 

자바 5는 Executor  프레임워크와 스레드 풀을 통해, 스레드의 파워를 높이는 기능을 제공했다. 

#### 스레드의 문제 
자바 스레드는 직접 운영체제 스레드에 접근한다. 운영체제 스레드를 만들고 종료하려면 비싼 비용을 치러야하며, 운영체제의 스레드의 숫자는 제한되어있다. OS가 지원하는 스레드 수를 초과하여 사용하는 경우 예상치 못한 방식으로 애플리케이션이 크래시 될 수 있다. 🔥 그러므로 기존 스레드가 실행되는 중에 계속 새로운 스레드가 만들어지는 상황은 없도록 해야한다. 

보통 OS 
